From c3bed60b63e76db5fdecc9eb8bafe04a611ece81 Mon Sep 17 00:00:00 2001
From: loongson <loongson@loongson-pc>
Date: Mon, 27 Mar 2023 17:54:58 +0800
Subject: [PATCH] add loongarch support

---
 Makefile                             |    2 +-
 asmcomp/CSEgen.ml                    |    3 +-
 asmcomp/deadcode.ml                  |    2 -
 asmcomp/liveness.ml                  |    2 -
 asmcomp/loongarch64/CSE.ml           |   39 +
 asmcomp/loongarch64/NOTES.md         |   13 +
 asmcomp/loongarch64/arch.ml          |   92 +
 asmcomp/loongarch64/arch.mli         |   75 +
 asmcomp/loongarch64/emit.mlp         |  770 ++++++++
 asmcomp/loongarch64/proc.ml          |  315 ++++
 asmcomp/loongarch64/reload.ml        |   19 +
 asmcomp/loongarch64/scheduling.ml    |   30 +
 asmcomp/loongarch64/selection.ml     |   68 +
 asmcomp/proc.mli                     |    2 +-
 build-aux/config.guess               |  388 +---
 build-aux/config.sub                 | 2562 +++++++++++++-------------
 configure.ac                         |   13 +-
 runtime/caml/domain_state.tbl        |   59 +
 runtime/caml/stack.h                 |   11 +
 runtime/loongarch64.S                |  828 +++++++++
 testsuite/tools/asmgen_loongarch64.S |   75 +
 21 files changed, 3754 insertions(+), 1614 deletions(-)
 create mode 100644 asmcomp/loongarch64/CSE.ml
 create mode 100644 asmcomp/loongarch64/NOTES.md
 create mode 100644 asmcomp/loongarch64/arch.ml
 create mode 100644 asmcomp/loongarch64/arch.mli
 create mode 100644 asmcomp/loongarch64/emit.mlp
 create mode 100644 asmcomp/loongarch64/proc.ml
 create mode 100644 asmcomp/loongarch64/reload.ml
 create mode 100644 asmcomp/loongarch64/scheduling.ml
 create mode 100644 asmcomp/loongarch64/selection.ml
 create mode 100644 runtime/loongarch64.S
 create mode 100644 testsuite/tools/asmgen_loongarch64.S

diff --git a/Makefile b/Makefile
index bb2c245..f639be7 100644
--- a/Makefile
+++ b/Makefile
@@ -41,7 +41,7 @@ include stdlib/StdlibModules
 
 CAMLC = $(BOOT_OCAMLC) $(BOOT_STDLIBFLAGS) -g -use-prims runtime/primitives
 CAMLOPT=$(OCAMLRUN) ./ocamlopt$(EXE) $(STDLIBFLAGS) -g -I otherlibs/dynlink
-ARCHES=amd64 i386 arm arm64 power s390x riscv
+ARCHES=amd64 i386 arm arm64 power s390x riscv loongarch64
 DIRS = utils parsing typing bytecomp file_formats lambda middle_end \
   middle_end/closure middle_end/flambda middle_end/flambda/base_types \
   asmcomp driver toplevel
diff --git a/asmcomp/CSEgen.ml b/asmcomp/CSEgen.ml
index dfdef4d..cbddd3b 100644
--- a/asmcomp/CSEgen.ml
+++ b/asmcomp/CSEgen.ml
@@ -304,8 +304,7 @@ method private cse n i =
               (* This operation was computed earlier. *)
               (* Are there registers that hold the results computed earlier? *)
               begin match find_regs_containing n1 vres with
-              | Some res when (not (self#is_cheap_operation op))
-                           && (not (Proc.regs_are_volatile res)) ->
+              | Some res when (not (self#is_cheap_operation op)) ->
                   (* We can replace res <- op args with r <- move res,
                      provided res are stable (non-volatile) registers.
                      If the operation is very cheap to compute, e.g.
diff --git a/asmcomp/deadcode.ml b/asmcomp/deadcode.ml
index 28fe153..e390a06 100644
--- a/asmcomp/deadcode.ml
+++ b/asmcomp/deadcode.ml
@@ -45,8 +45,6 @@ let rec deadcode i =
       let s = deadcode i.next in
       if operation_is_pure op                  (* no side effects *)
       && Reg.disjoint_set_array s.regs i.res   (* results are not used after *)
-      && not (Proc.regs_are_volatile i.arg)    (* no stack-like hard reg *)
-      && not (Proc.regs_are_volatile i.res)    (*            is involved *)
       then begin
         assert (Array.length i.res > 0);  (* sanity check *)
         s
diff --git a/asmcomp/liveness.ml b/asmcomp/liveness.ml
index 3cf1686..2ca3997 100644
--- a/asmcomp/liveness.ml
+++ b/asmcomp/liveness.ml
@@ -35,8 +35,6 @@ let transfer i ~next ~exn =
   | Iop op ->
       if operation_is_pure op                 (* no side effects *)
       && Reg.disjoint_set_array next i.res    (* results are not used after *)
-      && not (Proc.regs_are_volatile i.arg)   (* no stack-like hard reg *)
-      && not (Proc.regs_are_volatile i.res)   (*            is involved *)
       then begin
         (* This operation is dead code.  Ignore its arguments. *)
         i.live <- next;
diff --git a/asmcomp/loongarch64/CSE.ml b/asmcomp/loongarch64/CSE.ml
new file mode 100644
index 0000000..658bb66
--- /dev/null
+++ b/asmcomp/loongarch64/CSE.ml
@@ -0,0 +1,39 @@
+# 2 "asmcomp/loongarch64/CSE.ml"
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*                yala <zhaojunchao@loongson.cn>                          *)
+(*                                                                        *)
+(*               Copyright © 2008-2023 LOONGSON                           *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* CSE for the LoongArch *)
+
+open Arch
+open Mach
+open CSEgen
+
+class cse = object (_self)
+
+inherit cse_generic as super
+
+method! class_of_operation op =
+  match op with
+  | Ispecific(Imultaddf _ | Imultsubf _) -> Op_pure
+  | _ -> super#class_of_operation op
+
+method! is_cheap_operation op =
+  match op with
+  | Iconst_int n -> n <= 0x7FFF_FFFFn && n >= -0x8000_0000n
+  | _ -> false
+
+end
+
+let fundecl f =
+  (new cse)#fundecl f
diff --git a/asmcomp/loongarch64/NOTES.md b/asmcomp/loongarch64/NOTES.md
new file mode 100644
index 0000000..aacca61
--- /dev/null
+++ b/asmcomp/loongarch64/NOTES.md
@@ -0,0 +1,13 @@
+# Supported platforms
+
+LoongArch in 64-bit mode
+
+Debian architecture name: `loongarch64`
+
+# Reference documents
+
+* Instruction set specification:
+  - https://loongson.github.io/LoongArch-Documentation/LoongArch-Vol1-EN.html
+
+* ELF ABI specification:
+  - https://loongson.github.io/LoongArch-Documentation/LoongArch-ELF-ABI-EN.html
diff --git a/asmcomp/loongarch64/arch.ml b/asmcomp/loongarch64/arch.ml
new file mode 100644
index 0000000..0b12d5d
--- /dev/null
+++ b/asmcomp/loongarch64/arch.ml
@@ -0,0 +1,92 @@
+# 2 "asmcomp/loongarch64/arch.ml"
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*                yala <zhaojunchao@loongson.cn>                          *)
+(*                                                                        *)
+(*               Copyright © 2008-2023 LOONGSON                           *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Specific operations for the Loongarch processor *)
+
+open Format
+
+(* Machine-specific command-line options *)
+
+let command_line_options = []
+
+(* Specific operations *)
+
+type specific_operation =
+  | Imultaddf of bool        (* multiply, optionally negate, and add *)
+  | Imultsubf of bool        (* multiply, optionally negate, and subtract *)
+
+(* Addressing modes *)
+
+type addressing_mode =
+  | Iindexed of int                     (* reg + displ *)
+
+let is_immediate n =
+  (n <= 0x7FF) && (n >= -0x800)
+
+(* Sizes, endianness *)
+
+let big_endian = false
+
+let size_addr = 8
+let size_int = size_addr
+let size_float = 8
+
+let allow_unaligned_access = false
+
+(* Behavior of division *)
+
+let division_crashes_on_overflow = false
+
+(* Operations on addressing modes *)
+
+let identity_addressing = Iindexed 0
+
+let offset_addressing addr delta =
+  match addr with
+  | Iindexed n -> Iindexed(n + delta)
+
+let num_args_addressing = function
+  | Iindexed _ -> 1
+
+(* Printing operations and addressing modes *)
+
+let print_addressing printreg addr ppf arg =
+  match addr with
+  | Iindexed n ->
+      let idx = if n <> 0 then Printf.sprintf " + %i" n else "" in
+      fprintf ppf "%a%s" printreg arg.(0) idx
+
+let print_specific_operation printreg op ppf arg =
+  match op with
+  | Imultaddf false ->
+      fprintf ppf "%a *f %a +f %a"
+        printreg arg.(0) printreg arg.(1) printreg arg.(2)
+  | Imultaddf true ->
+      fprintf ppf "-f (%a *f %a +f %a)"
+        printreg arg.(0) printreg arg.(1) printreg arg.(2)
+  | Imultsubf false ->
+      fprintf ppf "%a *f %a -f %a"
+        printreg arg.(0) printreg arg.(1) printreg arg.(2)
+  | Imultsubf true ->
+      fprintf ppf "-f (%a *f %a -f %a)"
+        printreg arg.(0) printreg arg.(1) printreg arg.(2)
+
+(* Specific operations that are pure *)
+
+let operation_is_pure _ = true
+
+(* Specific operations that can raise *)
+
+let operation_can_raise _ = false
diff --git a/asmcomp/loongarch64/arch.mli b/asmcomp/loongarch64/arch.mli
new file mode 100644
index 0000000..089edcf
--- /dev/null
+++ b/asmcomp/loongarch64/arch.mli
@@ -0,0 +1,75 @@
+# 2 "asmcomp/loongarch64/arch.mli"
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*                yala <zhaojunchao@loongson.cn>                          *)
+(*                                                                        *)
+(*               Copyright © 2008-2023 LOONGSON                           *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Specific operations for the LoongArch processor *)
+
+(* Machine-specific command-line options *)
+
+val command_line_options : (string * Arg.spec * string) list
+
+(* Specific operations *)
+
+type specific_operation =
+  | Imultaddf of bool        (* multiply, optionally negate, and add *)
+  | Imultsubf of bool        (* multiply, optionally negate, and subtract *)
+
+(* Addressing modes *)
+
+type addressing_mode =
+  | Iindexed of int                     (* reg + displ *)
+
+val is_immediate : int -> bool
+
+(* Sizes, endianness *)
+
+val big_endian : bool
+
+val size_addr : int
+
+val size_int : int
+
+val size_float : int
+
+val allow_unaligned_access : bool
+
+(* Behavior of division *)
+
+val division_crashes_on_overflow : bool
+
+(* Operations on addressing modes *)
+
+val identity_addressing : addressing_mode
+
+val offset_addressing : addressing_mode -> int -> addressing_mode
+
+val num_args_addressing : addressing_mode -> int
+
+(* Printing operations and addressing modes *)
+
+val print_addressing :
+  (Format.formatter -> 'a -> unit) -> addressing_mode ->
+  Format.formatter -> 'a array -> unit
+
+val print_specific_operation :
+  (Format.formatter -> 'a -> unit) -> specific_operation ->
+  Format.formatter -> 'a array -> unit
+
+(* Specific operations that are pure *)
+
+val operation_is_pure : specific_operation -> bool
+
+(* Specific operations that can raise *)
+
+val operation_can_raise : specific_operation -> bool
diff --git a/asmcomp/loongarch64/emit.mlp b/asmcomp/loongarch64/emit.mlp
new file mode 100644
index 0000000..281b141
--- /dev/null
+++ b/asmcomp/loongarch64/emit.mlp
@@ -0,0 +1,770 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*                yala <zhaojunchao@loongson.cn>                          *)
+(*                                                                        *)
+(*               Copyright © 2008-2023 LOONGSON                           *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Emission of LoongArch assembly code *)
+
+open Cmm
+open Arch
+open Proc
+open Reg
+open Mach
+open Linear
+open Emitaux
+open Emitenv
+
+(* Layout of the stack.  The stack is kept 16-aligned. *)
+
+let frame_size env =
+  let size =
+    env.stack_offset  +                    (* Trap frame, outgoing parameters *)
+    size_int * env.f.fun_num_stack_slots.(0) +    (* Local int variables *)
+    size_float * env.f.fun_num_stack_slots.(1)+  (* Local float variables *)
+    (if env.f.fun_contains_calls then size_addr else 0) (* Return address *)
+  in
+  Misc.align size 16
+
+let slot_offset env loc cls =
+  match loc with
+  | Local n ->
+      ("$sp",
+       if cls = 0
+       then env.stack_offset + env.f.fun_num_stack_slots.(1) * size_float
+            + n * size_int
+       else env.stack_offset + n * size_float)
+  | Incoming n ->
+      ("$sp", frame_size env + n)
+  | Outgoing n ->
+      ("$sp", n)
+  | Domainstate n ->
+      ("$s8", n + Domainstate.(idx_of_field Domain_extra_params) * 8)
+
+(* Output a symbol *)
+
+let emit_symbol s =
+  emit_symbol '$' s
+
+let emit_jump op s =
+  if !Clflags.dlcode || !Clflags.pic_code
+  then `{emit_string op}	%plt({emit_symbol s})`
+  else `{emit_string op}	{emit_symbol s}`
+
+let emit_call = emit_jump "bl"
+let emit_tail = emit_jump "b"
+
+(* Output a label *)
+
+let emit_label lbl =
+  emit_string ".L"; emit_int lbl
+
+(* Section switching *)
+
+let data_space =
+  ".section .data"
+
+let code_space =
+  ".section .text"
+
+let rodata_space =
+  ".section .rodata"
+
+(* Names for special regs *)
+
+let reg_tmp = phys_reg 22               (* t1 *)
+let reg_tmp2 = phys_reg 21              (* t0 *)
+let reg_t2 = phys_reg 13                (* t2 *)
+let reg_domain_state_ptr = phys_reg 25  (* s8 *)
+let reg_trap_ptr = phys_reg 23          (* s1 *)
+let reg_alloc_ptr = phys_reg 24         (* s7 *)
+let reg_stack_arg_begin = phys_reg 9    (* s3 *)
+let reg_stack_arg_end = phys_reg 10     (* s4 *)
+
+(* Output a pseudo-register *)
+
+let reg_name = function
+  | {loc = Reg r} -> register_name r
+  | _ -> Misc.fatal_error "Emit.reg_name"
+
+let emit_reg r =
+  emit_string (reg_name r)
+
+(* Adjust sp by the given byte amount, clobbers reg_tmp *)
+
+let emit_stack_adjustment n =
+  if n <> 0 then begin
+    if is_immediate n then
+      `        addi.d    $sp, $sp, {emit_int n} \n`
+    else begin
+      `        li.d      {emit_reg reg_tmp}, {emit_int n}\n`;
+      `        add.d     $sp, $sp, {emit_reg reg_tmp}\n`
+    end;
+    cfi_adjust_cfa_offset (-n)
+  end
+
+(* Output add.d-immediate instruction, clobbers reg_tmp2 *)
+
+let emit_addimm rd rs n =
+  if is_immediate n then
+    `	addi.d	{emit_reg rd}, {emit_reg rs}, {emit_int n}\n`
+  else begin
+    `	li.d	{emit_reg reg_tmp2}, {emit_int n}\n`;
+    `	add.d	{emit_reg rd}, {emit_reg rs}, {emit_reg reg_tmp2}\n`
+  end
+
+(* Output memory operation with a possibly non-immediate offset,
+   clobbers reg_tmp *)
+
+let emit_mem_op op reg ofs addr =
+  if is_immediate ofs then
+    `	{emit_string op}	{emit_string reg}, {emit_string addr}, {emit_int ofs}\n`
+  else begin
+    `	li.d	{emit_reg reg_tmp}, {emit_int ofs}\n`;
+    `	add.d	{emit_reg reg_tmp}, {emit_string addr}, {emit_reg reg_tmp}\n`;
+    `	{emit_string op}	{emit_string reg}, {emit_reg reg_tmp}, 0\n`
+  end
+
+let reload_ra n =
+  emit_mem_op "ld.d" "$ra" (n - 8) "$sp"
+
+let store_ra n =
+  emit_mem_op "st.d" "$ra" (n - 8) "$sp"
+
+let emit_store rs ofs rd =
+  emit_mem_op "st.d" (reg_name rs) ofs rd
+
+let emit_load rd ofs rs =
+  emit_mem_op "ld.d" (reg_name rd) ofs rs
+
+let emit_float_load rd ofs rs =
+  emit_mem_op "fld.d" (reg_name rd) ofs rs
+
+let emit_float_store rs ofs rd =
+  emit_mem_op "fst.d" (reg_name rs) ofs rd
+
+let emit_float_test cmp ~arg ~res =
+  let negated =
+    match cmp with
+    | CFneq | CFnlt | CFngt | CFnle | CFnge -> true
+    | CFeq | CFlt | CFgt | CFle | CFge -> false
+  in
+  begin match cmp with
+  | CFeq | CFneq -> `	fcmp.ceq.d	$fcc0, {emit_reg arg.(0)}, {emit_reg arg.(1)}\n     movcf2gr {emit_reg res}, $fcc0\n`
+  | CFlt | CFnlt -> `	fcmp.clt.d	$fcc0, {emit_reg arg.(0)}, {emit_reg arg.(1)}\n     movcf2gr {emit_reg res}, $fcc0\n`
+  | CFgt | CFngt -> `	fcmp.clt.d	$fcc0, {emit_reg arg.(1)}, {emit_reg arg.(0)}\n     movcf2gr {emit_reg res}, $fcc0\n`
+  | CFle | CFnle -> `	fcmp.cle.d	$fcc0, {emit_reg arg.(0)}, {emit_reg arg.(1)}\n     movcf2gr {emit_reg res}, $fcc0\n`
+  | CFge | CFnge -> `	fcmp.cle.d	$fcc0, {emit_reg arg.(1)}, {emit_reg arg.(0)}\n     movcf2gr {emit_reg res}, $fcc0\n`
+  end;
+  negated
+
+(* Record live pointers at call points *)
+
+let record_frame_label env live dbg =
+  let lbl = new_label () in
+  let live_offset = ref [] in
+  Reg.Set.iter
+    (function
+        {typ = Val; loc = Reg r} ->
+          live_offset := (r lsl 1) + 1 :: !live_offset
+      | {typ = Val; loc = Stack s} as reg ->
+          let (base, ofs) = slot_offset env s (register_class reg) in
+          assert (base = "$sp");
+          live_offset := ofs :: !live_offset
+      | {typ = Addr} as r ->
+          Misc.fatal_error ("bad GC root " ^ Reg.name r)
+      | _ -> ()
+    )
+    live;
+  record_frame_descr ~label:lbl ~frame_size:(frame_size env)
+    ~live_offset:!live_offset dbg;
+  lbl
+
+let record_frame env live dbg =
+  let lbl = record_frame_label env live dbg in
+  `{emit_label lbl}:\n`
+
+let emit_call_gc gc =
+  `{emit_label gc.gc_lbl}:\n`;
+  `	{emit_call "caml_call_gc"}\n`;
+  `{emit_label gc.gc_frame_lbl}:\n`;
+  `	b	{emit_label gc.gc_return_lbl}\n`
+
+let bound_error_label env dbg =
+  if !Clflags.debug || env.bound_error_sites = [] then begin
+    let lbl_bound_error = new_label() in
+    let lbl_frame = record_frame_label env Reg.Set.empty (Dbg_other dbg) in
+    env.bound_error_sites <-
+      { bd_lbl = lbl_bound_error;
+        bd_frame = lbl_frame; } :: env.bound_error_sites;
+    lbl_bound_error
+  end else
+    let bd = List.hd env.bound_error_sites in
+    bd.bd_lbl
+
+let emit_call_bound_error bd =
+  `{emit_label bd.bd_lbl}:\n`;
+  `	{emit_call "caml_ml_array_bound_error"}\n`;
+  `{emit_label bd.bd_frame}:\n`
+
+(* Names for various instructions *)
+
+let name_for_intop = function
+  | Iadd  -> "add.d"
+  | Isub  -> "sub.d"
+  | Imul  -> "mul.d"
+  | Imulh -> "mulh.d"
+  | Idiv  -> "div.d"
+  | Iand  -> "and"
+  | Ior   -> "or"
+  | Ixor  -> "xor"
+  | Ilsl  -> "sll.d"
+  | Ilsr  -> "srl.d"
+  | Iasr  -> "sra.d"
+  | Imod  -> "mod.d"
+  | _ -> Misc.fatal_error "Emit.Intop"
+
+let name_for_intop_imm = function
+  | Iadd -> "addi.d"
+  | Iand -> "andi"
+  | Ior  -> "ori"
+  | Ixor -> "xori"
+  | Ilsl -> "slli.d"
+  | Ilsr -> "srli.d"
+  | Iasr -> "srai.d"
+  | _ -> Misc.fatal_error "Emit.Intop_imm"
+
+let name_for_floatop1 = function
+  | Inegf -> "fneg.d"
+  | Iabsf -> "fabs.d"
+  | _ -> Misc.fatal_error "Emit.Iopf1"
+
+let name_for_floatop2 = function
+  | Iaddf -> "fadd.d"
+  | Isubf -> "fsub.d"
+  | Imulf -> "fmul.d"
+  | Idivf -> "fdiv.d"
+  | _ -> Misc.fatal_error "Emit.Iopf2"
+
+let name_for_specific = function
+  | Imultaddf false -> "fmadd.d"
+  | Imultaddf true  -> "fnmadd.d"
+  | Imultsubf false -> "fmsub.d"
+  | Imultsubf true  -> "fnmsub.d"
+
+(* Output the assembly code for an instruction *)
+
+let emit_instr env i =
+  emit_debug_info i.dbg;
+  match i.desc with
+    Lend -> ()
+  | Lprologue ->
+      assert (env.f.fun_prologue_required);
+      let n = frame_size env in
+      emit_stack_adjustment (-n);
+      if env.f.fun_contains_calls then begin
+        store_ra n;
+        cfi_offset ~reg:1 (* ra *) ~offset:(-8)
+      end;
+  | Lop(Imove | Ispill | Ireload) ->
+      let src = i.arg.(0) and dst = i.res.(0) in
+      if src.loc <> dst.loc then begin
+        match (src, dst) with
+        | {loc = Reg _; typ = (Val | Int | Addr)}, {loc = Reg _} ->
+            `	move      {emit_reg dst}, {emit_reg src}\n`
+        | {loc = Reg _; typ = Float}, {loc = Reg _; typ = Float} ->
+            `	fmov.d   {emit_reg dst}, {emit_reg src}\n`
+        | {loc = Reg _; typ = (Val | Int | Addr)}, {loc = Stack s} ->
+            let (base, ofs) = slot_offset env s (register_class dst) in
+            emit_store src ofs base
+        | {loc = Reg _; typ = Float}, {loc = Stack s} ->
+            let (base, ofs) = slot_offset env s (register_class dst) in
+            emit_float_store src ofs base
+        | {loc = Stack s; typ = (Val | Int | Addr)}, {loc = Reg _} ->
+            let (base, ofs) = slot_offset env s (register_class src) in
+            emit_load dst ofs base
+        | {loc = Stack s; typ = Float}, {loc = Reg _} ->
+            let (base, ofs) = slot_offset env s (register_class src) in
+            emit_float_load dst ofs base
+        | {loc = Reg _; typ = Float}, {loc = Reg _; typ = (Val | Int | Addr)}
+        | {loc = Stack _}, {loc = Stack _}
+        | {loc = Unknown}, _ | _, {loc = Unknown} ->
+            Misc.fatal_error "Emit: Imove"
+      end
+  | Lop(Iconst_int n) ->
+      `	li.d	{emit_reg i.res.(0)}, {emit_nativeint n}\n`
+  | Lop(Iconst_float f) ->
+      let lbl = new_label() in
+      env.float_literals <- {fl=f; lbl} :: env.float_literals;
+      `la.local {emit_reg reg_tmp}, {emit_label lbl} \n`;
+      `	fld.d	{emit_reg i.res.(0)}, {emit_reg reg_tmp}, 0\n`
+  | Lop(Iconst_symbol s) ->     (* FIXME la.global assert error in binutils*)
+      `pcaddi {emit_reg i.res.(0)}, 0 \n`;
+      `b 7112233f\n`;
+      `.dword {emit_symbol s}\n`;
+      `7112233: ld.d {emit_reg i.res.(0)}, {emit_reg i.res.(0)}, 8\n`
+  | Lop(Icall_ind) ->
+      `	jirl	$ra, {emit_reg i.arg.(0)}, 0\n`;
+      record_frame env i.live (Dbg_other i.dbg)
+  | Lop(Icall_imm {func}) ->
+      `	{emit_call func}\n`;
+      record_frame env i.live (Dbg_other i.dbg)
+  | Lop(Itailcall_ind) ->
+      let n = frame_size env in
+      if env.f.fun_contains_calls then reload_ra n;
+      emit_stack_adjustment n;
+      `	jr	{emit_reg i.arg.(0)}\n`
+  | Lop(Itailcall_imm {func}) ->
+      if func = env.f.fun_name then begin
+        `	b	{emit_label env.f.fun_tailrec_entry_point_label}\n`
+      end else begin
+        let n = frame_size env in
+        if env.f.fun_contains_calls then reload_ra n;
+        emit_stack_adjustment n;
+        `	{emit_tail func}\n`
+      end
+  | Lop(Iextcall{func; alloc; stack_ofs}) ->
+      if stack_ofs > 0 then begin
+        `	move	{emit_reg reg_stack_arg_begin}, $sp\n`;
+        `	addi.d	{emit_reg reg_stack_arg_end}, $sp, {emit_int (Misc.align stack_ofs 16)}\n`;
+        `	la.global	{emit_reg reg_t2}, {emit_symbol func}\n`;
+        `	{emit_call "caml_c_call_stack_args"}\n`;
+        record_frame env i.live (Dbg_other i.dbg)
+      end else if alloc then begin
+        `	la.global	{emit_reg reg_t2}, {emit_symbol func}\n`;
+        `	{emit_call "caml_c_call"}\n`;
+        record_frame env i.live (Dbg_other i.dbg)
+      end else begin
+        (* store ocaml stack in s0, which is marked as being destroyed
+           at noalloc calls *)
+        `	move	$s0, $sp\n`;
+        cfi_remember_state ();
+        cfi_def_cfa_register ~reg:21;
+        let ofs = Domainstate.(idx_of_field Domain_c_stack) * 8 in
+        `	ld.d	$sp, {emit_reg reg_domain_state_ptr}, {emit_int ofs}\n`;
+        `	{emit_call func}\n`;
+        `	move	$sp, $s0\n`;
+        cfi_restore_state ()
+      end
+  | Lop(Istackoffset n) ->
+      assert (n mod 16 = 0);
+      emit_stack_adjustment (-n);
+      env.stack_offset <- env.stack_offset + n
+  | Lop(Iload { memory_chunk = Single; addressing_mode = Iindexed ofs; is_atomic } ) ->
+      assert (not is_atomic);
+      `	fld.s	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_int ofs}\n`;
+      `	fcvt.d.s	{emit_reg i.res.(0)}, {emit_reg i.res.(0)}\n`
+  | Lop(Iload { memory_chunk = Word_int | Word_val; addressing_mode = Iindexed ofs; is_atomic } ) ->
+      if is_atomic then `	dbar    0\n`;
+      `	ld.d	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_int ofs}\n`;
+      if is_atomic then `	dbar    0\n`
+  | Lop(Iload { memory_chunk; addressing_mode = Iindexed ofs; is_atomic } ) ->
+      assert (not is_atomic);
+      let instr =
+        match memory_chunk with
+        | Byte_unsigned -> "ld.bu"
+        | Byte_signed -> "ld.b"
+        | Sixteen_unsigned -> "ld.hu"
+        | Sixteen_signed -> "ld.h"
+        | Thirtytwo_unsigned -> "ld.wu"
+        | Thirtytwo_signed -> "ld.w"
+        | Word_int | Word_val | Single -> assert false
+        | Double -> "fld.d"
+      in
+      `	{emit_string instr}	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_int ofs}\n`
+  | Lop(Istore(Single, Iindexed ofs, _)) ->
+      (* ft0 is marked as destroyed for this operation *)
+      `	fcvt.s.d	$ft0, {emit_reg i.arg.(0)}\n`;
+      `	fst.s	$ft0, {emit_reg i.arg.(1)}, {emit_int ofs}\n`
+  | Lop(Istore((Word_int | Word_val), Iindexed ofs, assignement)) ->
+      if assignement then begin
+        `	dbar	0\n`;
+        `	st.d	{emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}, {emit_int ofs}\n`
+      end else
+        `	st.d	{emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}, {emit_int ofs}\n`;
+  | Lop(Istore(chunk, Iindexed ofs, _)) ->
+      let instr =
+        match chunk with
+        | Byte_unsigned | Byte_signed -> "st.b"
+        | Sixteen_unsigned | Sixteen_signed -> "st.h"
+        | Thirtytwo_unsigned | Thirtytwo_signed -> "st.w"
+        | Word_int | Word_val | Single -> assert false
+        | Double -> "fst.d"
+      in
+      `	{emit_string instr}	{emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}, {emit_int ofs}\n`
+  | Lop(Ialloc {bytes; dbginfo}) ->
+      let lbl_frame_lbl = record_frame_label env i.live (Dbg_alloc dbginfo) in
+      if env.f.fun_fast then begin
+        let lbl_after_alloc = new_label () in
+        let lbl_call_gc = new_label () in
+        let n = -bytes in
+        let offset = Domainstate.(idx_of_field Domain_young_limit) * 8 in
+        emit_addimm reg_alloc_ptr reg_alloc_ptr n;
+        `	ld.d	{emit_reg reg_tmp}, {emit_reg reg_domain_state_ptr}, {emit_int offset}\n`;
+        `	bltu	{emit_reg reg_alloc_ptr}, {emit_reg reg_tmp}, {emit_label lbl_call_gc}\n`;
+        `{emit_label lbl_after_alloc}:\n`;
+        `	addi.d	{emit_reg i.res.(0)}, {emit_reg reg_alloc_ptr}, 8\n`;
+        env.call_gc_sites <-
+          { gc_lbl = lbl_call_gc;
+            gc_return_lbl = lbl_after_alloc;
+            gc_frame_lbl = lbl_frame_lbl } :: env.call_gc_sites
+      end else begin
+        begin match bytes with
+        | 16 -> `	{emit_call "caml_alloc1"}\n`
+        | 24 -> `	{emit_call "caml_alloc2"}\n`
+        | 32 -> `	{emit_call "caml_alloc3"}\n`
+        | _  ->
+            `	li.d	{emit_reg reg_t2}, {emit_int bytes}\n`;
+            `	{emit_call "caml_allocN"}\n`
+        end;
+        `{emit_label lbl_frame_lbl}:\n`;
+        `	addi.d	{emit_reg i.res.(0)}, {emit_reg reg_alloc_ptr}, 8\n`
+      end
+  | Lop(Ipoll { return_label }) ->
+      let lbl_frame_lbl = record_frame_label env i.live (Dbg_alloc []) in
+      let lbl_after_poll = match return_label with
+                  | None -> new_label()
+                  | Some(lbl) -> lbl in
+      let lbl_call_gc = new_label () in
+      let offset = Domainstate.(idx_of_field Domain_young_limit) * 8 in
+      `	ld.d	{emit_reg reg_tmp}, {emit_reg reg_domain_state_ptr}, {emit_int offset}\n`;
+      begin match return_label with
+      | None -> `	bltu	{emit_reg reg_alloc_ptr}, {emit_reg reg_tmp}, {emit_label lbl_call_gc}\n`;
+                `{emit_label lbl_after_poll}:\n`;
+      | Some lbl -> ` bgeu  {emit_reg reg_alloc_ptr}, {emit_reg reg_tmp}, {emit_label lbl}\n`;
+                    ` b {emit_label lbl_call_gc}\n`
+      end;
+      env.call_gc_sites <-
+        { gc_lbl = lbl_call_gc;
+          gc_return_lbl = lbl_after_poll;
+          gc_frame_lbl = lbl_frame_lbl } :: env.call_gc_sites
+  | Lop(Iintop(Icomp cmp)) ->
+      begin match cmp with
+      | Isigned Clt ->
+          `	slt	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`
+      | Isigned Cge ->
+          `	slt	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
+          `	xori	{emit_reg i.res.(0)}, {emit_reg i.res.(0)}, 1\n`;
+      | Isigned Cgt ->
+          `	slt	{emit_reg i.res.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.arg.(0)}\n`
+      | Isigned Cle ->
+          `	slt	{emit_reg i.res.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.arg.(0)}\n`;
+          `	xori	{emit_reg i.res.(0)}, {emit_reg i.res.(0)}, 1\n`;
+      | Isigned Ceq | Iunsigned Ceq ->
+          `	sub.d	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
+          `	sltui	{emit_reg i.res.(0)}, {emit_reg i.res.(0)}, 1\n`
+      | Isigned Cne | Iunsigned Cne ->
+          `	sub.d	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
+          `	sltu	{emit_reg i.res.(0)}, $zero, {emit_reg i.res.(0)}\n`
+      | Iunsigned Clt ->
+          `	sltu	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`
+      | Iunsigned Cge ->
+          `	sltu	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
+          `	xori	{emit_reg i.res.(0)}, {emit_reg i.res.(0)}, 1\n`;
+      | Iunsigned Cgt ->
+          `	sltu	{emit_reg i.res.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.arg.(0)}\n`
+      | Iunsigned Cle ->
+          `	sltu	{emit_reg i.res.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.arg.(0)}\n`;
+          `	xori	{emit_reg i.res.(0)}, {emit_reg i.res.(0)}, 1\n`;
+      end
+  | Lop(Iintop (Icheckbound)) ->
+      let lbl = bound_error_label env i.dbg in
+      `	bleu	{emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}, {emit_label lbl}\n`
+  | Lop(Iintop op) ->
+      let instr = name_for_intop op in
+      `	{emit_string instr}	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`
+  | Lop(Iintop_imm(Isub, n)) ->
+      `	addi.d	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_int(-n)}\n`
+  | Lop(Iintop_imm(Iadd, n)) ->
+      `	addi.d	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_int(n)}\n`
+  | Lop(Iintop_imm(op, n)) ->
+      let instri = name_for_intop_imm op in
+      if n<0 then  (* FIXME *)
+          let instr = name_for_intop op in
+          ` addi.d   {emit_reg reg_tmp2}, $zero, {emit_int n}\n {emit_string instr}    {emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg reg_tmp2} \n`
+      else
+      `	{emit_string instri}	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_int n}\n`
+  | Lop(Inegf | Iabsf as op) ->
+      let instr = name_for_floatop1 op in
+      `	{emit_string instr}	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}\n`
+  | Lop(Iaddf | Isubf | Imulf | Idivf as op) ->
+      let instr = name_for_floatop2 op in
+      `	{emit_string instr}	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`
+  | Lop(Ifloatofint) ->
+      ` movgr2fr.d  $ft0, {emit_reg i.arg.(0)} \n`;
+      `	ffint.d.l	{emit_reg i.res.(0)}, $ft0\n`
+  | Lop(Iintoffloat) ->
+      `	ftintrz.l.d	$ft0, {emit_reg i.arg.(0)}\n`;
+      ` movfr2gr.d  {emit_reg i.res.(0)}, $ft0 \n`
+  | Lop(Iopaque) ->
+      assert (i.arg.(0).loc = i.res.(0).loc)
+  | Lop(Ispecific sop) ->
+      let instr = name_for_specific sop in
+      `	{emit_string instr}	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.arg.(2)}\n`
+  | Lop (Idls_get) ->
+      let ofs = Domainstate.(idx_of_field Domain_dls_root) * 8 in
+      `	ld.d	{emit_reg i.res.(0)}, {emit_reg reg_domain_state_ptr}, {emit_int ofs}\n`
+  | Lreloadretaddr ->
+      let n = frame_size env in
+      reload_ra n
+  | Lreturn ->
+      let n = frame_size env in
+      emit_stack_adjustment n;
+      `	jr  $ra\n`
+  | Llabel lbl ->
+      `{emit_label lbl}:\n`
+  | Lbranch lbl ->
+      `	b	{emit_label lbl}\n`
+  | Lcondbranch(tst, lbl) ->
+      begin match tst with
+      | Itruetest ->
+          `	bnez	{emit_reg i.arg.(0)}, {emit_label lbl}\n`
+      | Ifalsetest ->
+          `	beqz	{emit_reg i.arg.(0)}, {emit_label lbl}\n`
+      | Iinttest cmp ->
+          let name = match cmp with
+            | Iunsigned Ceq | Isigned Ceq -> "beq"
+            | Iunsigned Cne | Isigned Cne -> "bne"
+            | Iunsigned Cle -> "bleu" | Isigned Cle -> "ble"
+            | Iunsigned Cge -> "bgeu" | Isigned Cge -> "bge"
+            | Iunsigned Clt -> "bltu" | Isigned Clt -> "blt"
+            | Iunsigned Cgt -> "bgtu" | Isigned Cgt -> "bgt"
+          in
+          `	{emit_string name}	{emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}, {emit_label lbl}\n`
+      | Iinttest_imm _ ->
+          Misc.fatal_error "Emit.emit_instr (Iinttest_imm _)"
+      | Ifloattest cmp ->
+          let negated = emit_float_test cmp ~arg:i.arg ~res:reg_tmp in
+          let branch =
+            if negated
+            then "beqz"
+            else "bnez"
+          in
+          `	{emit_string branch}	{emit_reg reg_tmp}, {emit_label lbl}\n`
+      | Ioddtest ->
+          `	andi	{emit_reg reg_tmp}, {emit_reg i.arg.(0)}, 1\n`;
+          `	bnez	{emit_reg reg_tmp}, {emit_label lbl}\n`
+      | Ieventest ->
+          `	andi	{emit_reg reg_tmp}, {emit_reg i.arg.(0)}, 1\n`;
+          `	beqz	{emit_reg reg_tmp}, {emit_label lbl}\n`
+      end
+  | Lcondbranch3(lbl0, lbl1, lbl2) ->
+      `	addi.d	{emit_reg reg_tmp}, {emit_reg i.arg.(0)}, -1\n`;
+      begin match lbl0 with
+      | None -> ()
+      | Some lbl -> `	bltz	{emit_reg reg_tmp}, {emit_label lbl}\n`
+      end;
+      begin match lbl1 with
+      | None -> ()
+      | Some lbl -> `	beqz	{emit_reg reg_tmp}, {emit_label lbl}\n`
+      end;
+      begin match lbl2 with
+      | None -> ()
+      | Some lbl -> `	bgtz	{emit_reg reg_tmp}, {emit_label lbl}\n`
+      end
+  | Lswitch jumptbl ->
+      let lbl = new_label() in
+      `	la.local	{emit_reg reg_tmp}, {emit_label lbl}\n`;
+      `	slli.d	{emit_reg reg_tmp2}, {emit_reg i.arg.(0)}, 2\n`;
+      `	add.d	{emit_reg reg_tmp}, {emit_reg reg_tmp}, {emit_reg reg_tmp2}\n`;
+      `	jr	{emit_reg reg_tmp}\n`;
+      `{emit_label lbl}:\n`;
+      for i = 0 to Array.length jumptbl - 1 do
+        `	b	{emit_label jumptbl.(i)}\n`
+      done
+  | Lentertrap ->
+      ()
+  | Ladjust_trap_depth { delta_traps } ->
+      (* each trap occupes 16 bytes on the stack *)
+      let delta = 16 * delta_traps in
+      cfi_adjust_cfa_offset delta;
+      env.stack_offset <- env.stack_offset + delta
+  | Lpushtrap {lbl_handler} ->
+      `	la.local	{emit_reg reg_tmp}, {emit_label lbl_handler}\n`;
+      `	addi.d	$sp, $sp, -16\n`;
+      env.stack_offset <- env.stack_offset + 16;
+      `	st.d	{emit_reg reg_trap_ptr}, $sp, 0\n`;
+      `	st.d	{emit_reg reg_tmp}, $sp, 8\n`;
+      cfi_adjust_cfa_offset 16;
+      `	move	{emit_reg reg_trap_ptr}, $sp\n`
+  | Lpoptrap ->
+      `	ld.d	{emit_reg reg_trap_ptr}, $sp, 0\n`;
+      `	addi.d	$sp, $sp, 16\n`;
+      cfi_adjust_cfa_offset (-16);
+      env.stack_offset <- env.stack_offset - 16
+  | Lraise k ->
+      begin match k with
+      | Lambda.Raise_regular ->
+          `	{emit_call "caml_raise_exn"}\n`;
+          record_frame env Reg.Set.empty (Dbg_raise i.dbg)
+      | Lambda.Raise_reraise ->
+          `	{emit_call "caml_reraise_exn"}\n`;
+          record_frame env Reg.Set.empty (Dbg_raise i.dbg)
+      | Lambda.Raise_notrace ->
+          `	move	$sp, {emit_reg reg_trap_ptr}\n`;
+          `	ld.d	{emit_reg reg_tmp}, $sp, 8\n`;
+          `	ld.d	{emit_reg reg_trap_ptr}, $sp, 0\n`;
+          `	addi.d	$sp, $sp, 16\n`;
+          `	jr	{emit_reg reg_tmp}\n`
+      end
+
+(* Emit a sequence of instructions *)
+
+let rec emit_all env = function
+  | {desc = Lend} -> () | i -> emit_instr env i; emit_all env i.next
+
+(* Emission of a function declaration *)
+
+let fundecl fundecl =
+  let env = mk_env fundecl in
+  `	.globl	{emit_symbol fundecl.fun_name}\n`;
+  `	.type	{emit_symbol fundecl.fun_name}, @function\n`;
+  `	{emit_string code_space}\n`;
+  `	.align	2\n`;
+  `{emit_symbol fundecl.fun_name}:\n`;
+  emit_debug_info fundecl.fun_dbg;
+  cfi_startproc();
+
+  (* Dynamic stack checking *)
+  let stack_threshold_size = Config.stack_threshold * 8 in (* bytes *)
+  let { max_frame_size; contains_nontail_calls } =
+    preproc_stack_check
+      ~fun_body:fundecl.fun_body ~frame_size:(frame_size env) ~trap_size:16
+  in
+  let handle_overflow = ref None in
+  if contains_nontail_calls || max_frame_size >= stack_threshold_size then begin
+    let overflow = new_label () and ret = new_label () in
+    let threshold_offset = Domainstate.stack_ctx_words * 8 + stack_threshold_size in
+    let f = max_frame_size + threshold_offset in
+    let offset = Domainstate.(idx_of_field Domain_current_stack) * 8 in
+    `	ld.d	{emit_reg reg_tmp}, {emit_reg reg_domain_state_ptr}, {emit_int offset}\n`;
+    emit_addimm reg_tmp reg_tmp f;
+    `	bltu	$sp, {emit_reg reg_tmp}, {emit_label overflow}\n`;
+    `{emit_label ret}:\n`;
+    handle_overflow := Some (overflow, ret)
+  end;
+
+  emit_all env fundecl.fun_body;
+  List.iter emit_call_gc env.call_gc_sites;
+  List.iter emit_call_bound_error env.bound_error_sites;
+
+  begin match !handle_overflow with
+  | None -> ()
+  | Some (overflow, ret) ->
+      `{emit_label overflow}:\n`;
+      (* Pass the desired frame size on the stack, since all of the
+         argument-passing registers may be in use. *)
+      let s = Config.stack_threshold + max_frame_size / 8 in
+      `	li.d	{emit_reg reg_tmp}, {emit_int s}\n`;
+      `	addi.d	$sp, $sp, -16\n`;
+      `	st.d	{emit_reg reg_tmp}, $sp, 0\n`;
+      `	st.d	$ra, $sp, 8\n`;
+      `	{emit_call "caml_call_realloc_stack"}\n`;
+      `	ld.d	$ra, $sp, 8\n`;
+      `	addi.d	$sp, $sp, 16\n`;
+      `	b	{emit_label ret}\n`
+  end;
+
+  cfi_endproc();
+  `	.size	{emit_symbol fundecl.fun_name}, .-{emit_symbol fundecl.fun_name}\n`;
+  (* Emit the float literals *)
+  if env.float_literals <> [] then begin
+    `	{emit_string rodata_space}\n`;
+    `	.align	3\n`;
+    List.iter
+      (fun {fl; lbl} ->
+        `{emit_label lbl}:\n`;
+        emit_float64_directive ".quad" fl)
+      env.float_literals;
+  end
+
+(* Emission of data *)
+
+let declare_global_data s =
+  `	.globl	{emit_symbol s}\n`;
+  `	.type	{emit_symbol s}, @object\n`
+
+let emit_item = function
+  | Cglobal_symbol s ->
+      declare_global_data s
+  | Cdefine_symbol s ->
+      `{emit_symbol s}:\n`;
+  | Cint8 n ->
+      `	.byte	{emit_int n}\n`
+  | Cint16 n ->
+      `	.short	{emit_int n}\n`
+  | Cint32 n ->
+      `	.long	{emit_nativeint n}\n`
+  | Cint n ->
+      `	.quad	{emit_nativeint n}\n`
+  | Csingle f ->
+      emit_float32_directive ".long" (Int32.bits_of_float f)
+  | Cdouble f ->
+      emit_float64_directive ".quad" (Int64.bits_of_float f)
+  | Csymbol_address s ->
+      `	.quad	{emit_symbol s}\n`
+  | Cstring s ->
+      emit_bytes_directive "	.byte	" s
+  | Cskip n ->
+      if n > 0 then `	.space	{emit_int n}\n`
+  | Calign n ->
+      `	.align	{emit_int (Misc.log2 n)}\n`
+
+let data l =
+  `	{emit_string data_space}\n`;
+  List.iter emit_item l
+
+(* Beginning / end of an assembly file *)
+
+let begin_assembly() =
+  if !Clflags.dlcode || !Clflags.pic_code then `	\n`;  (* FIXME *)
+  `	.file \"\"\n`; (* PR#7073 *)
+  reset_debug_info ();
+  (* Emit the beginning of the segments *)
+  let lbl_begin = Compilenv.make_symbol (Some "data_begin") in
+  `	{emit_string data_space}\n`;
+  declare_global_data lbl_begin;
+  `{emit_symbol lbl_begin}:\n`;
+  let lbl_begin = Compilenv.make_symbol (Some "code_begin") in
+  `	{emit_string code_space}\n`;
+  declare_global_data lbl_begin;
+  `{emit_symbol lbl_begin}:\n`
+
+let end_assembly() =
+  `	{emit_string code_space}\n`;
+  let lbl_end = Compilenv.make_symbol (Some "code_end") in
+  declare_global_data lbl_end;
+  `{emit_symbol lbl_end}:\n`;
+  `	.long	0\n`;
+  `	{emit_string data_space}\n`;
+  let lbl_end = Compilenv.make_symbol (Some "data_end") in
+  declare_global_data lbl_end;
+  `    .quad   0\n`; (* PR#6329 *)
+  `{emit_symbol lbl_end}:\n`;
+  `	.quad	0\n`;
+  (* Emit the frame descriptors *)
+  `	{emit_string data_space}\n`; (* not rodata because relocations inside *)
+  let lbl = Compilenv.make_symbol (Some "frametable") in
+  declare_global_data lbl;
+  `{emit_symbol lbl}:\n`;
+  emit_frames
+    { efa_code_label = (fun l -> `	.quad	{emit_label l}\n`);
+      efa_data_label = (fun l -> `	.quad	{emit_label l}\n`);
+      efa_8 = (fun n -> `	.byte	{emit_int n}\n`);
+      efa_16 = (fun n -> `	.short	{emit_int n}\n`);
+      efa_32 = (fun n -> `	.long	{emit_int32 n}\n`);
+      efa_word = (fun n -> `	.quad	{emit_int n}\n`);
+      efa_align = (fun n -> `	.align	{emit_int (Misc.log2 n)}\n`);
+      efa_label_rel = (fun lbl ofs ->
+                           `	.long	({emit_label lbl} - .) + {emit_int32 ofs}\n`);
+      efa_def_label = (fun l -> `{emit_label l}:\n`);
+      efa_string = (fun s -> emit_bytes_directive "	.byte	" (s ^ "\000"))
+     }
diff --git a/asmcomp/loongarch64/proc.ml b/asmcomp/loongarch64/proc.ml
new file mode 100644
index 0000000..afcd65a
--- /dev/null
+++ b/asmcomp/loongarch64/proc.ml
@@ -0,0 +1,315 @@
+# 2 "asmcomp/loongarch64/proc.ml"
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*                yala <zhaojunchao@loongson.cn>                          *)
+(*                                                                        *)
+(*               Copyright © 2008-2023 LOONGSON                           *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Description of the LoongArch *)
+
+open Misc
+open Cmm
+open Reg
+open Arch
+open Mach
+
+(* Instruction selection *)
+
+let word_addressed = false
+
+(* Registers available for register allocation *)
+
+(* Integer register map
+   --------------------
+
+    zero                   always zero
+    ra                     return address
+    sp, gp, tp             stack pointer, global pointer, thread pointer
+    a0-a7        0-7       arguments/results
+    s2-s6        8-12      arguments/results (preserved by C)
+    t2-t6        13-17     temporary
+    s0           18        general purpose (preserved by C)
+    t0, t1       19-20     temporaries (used by call veneers)
+    s1           21        trap pointer (preserved by C)
+    s7          22        allocation pointer (preserved by C)
+    s8          23        domain pointer (preserved by C)
+
+  Floating-point register map
+  ---------------------------
+
+    f0-f7    100-107     arguments
+    f0-f1    100-101     arguments/results
+    f8-f23   108-123     temporary
+    f24-f31  124-131     subroutine register variables
+
+  Additional notes
+  ----------------
+
+    - t1 is used by the code generator, so not available for register
+      allocation.
+
+    - t0-t6 may be used by PLT stubs, so should not be used to pass
+      arguments and may be clobbered by [Ialloc] in the presence of dynamic
+      linking.
+*)
+
+let int_reg_name =
+    [|"$a0"; "$a1"; "$a2"; "$a3"; "$a4"; "$a5"; "$a6"; "$a7";  (* 0- 7 *)
+      "$s2"; "$s3"; "$s4"; "$s5"; "$s6";                       (* 8-12*)
+      "$t2"; "$t3"; "$t4"; "$t5"; "$t6"; "$t7"; "$t8";          (*13-19*)
+      "$s0";                                                   (*20*)
+      "$t0"; "$t1";                                            (*21-22*)
+      "$s1"; "$s7"; "$s8";                                      (*23-25*)
+    |]
+
+let float_reg_name =
+  [| "$ft0"; "$ft1"; "$ft2"; "$ft3"; "$ft4"; "$ft5"; "$ft6";"$ft7";     (*100-107*)
+     "$fs0"; "$fs1";                                              (*108-109*)
+     "$fa0"; "$fa1"; "$fa2"; "$fa3"; "$fa4"; "$fa5"; "$fa6"; "$fa7";    (*110-117*)
+     "$fs2"; "$fs3"; "$fs4"; "$fs5"; "$fs6"; "$fs7";                  (*118-123*)
+     "$ft8"; "$ft9"; "$ft10"; "$ft11";"$ft12";"$ft13";"$ft14";"$ft15"; |] (*124-131*)
+let num_register_classes = 2
+
+let register_class r =
+  match r.typ with
+  | Val | Int | Addr -> 0
+  | Float -> 1
+
+(* first 19 int regs allocatable; all float regs allocatable *)
+let num_available_registers = [| 21; 32 |]
+
+let first_available_register = [| 0; 100 |]
+
+let register_name r =
+  if r < 100 then int_reg_name.(r) else float_reg_name.(r - 100)
+
+let rotate_registers = true
+
+(* Representation of hard registers by pseudo-registers *)
+
+let hard_int_reg =
+  let v = Array.make 26 Reg.dummy in
+  for i = 0 to 25 do
+    v.(i) <- Reg.at_location Int (Reg i)
+  done;
+  v
+
+let hard_float_reg =
+  let v = Array.make 32 Reg.dummy in
+  for i = 0 to 31 do
+    v.(i) <- Reg.at_location Float (Reg(100 + i))
+  done;
+  v
+
+let all_phys_regs =
+  Array.append hard_int_reg hard_float_reg
+
+let phys_reg n =
+  if n < 100 then hard_int_reg.(n) else hard_float_reg.(n - 100)
+
+let stack_slot slot ty =
+  Reg.at_location ty (Stack slot)
+
+(* Calling conventions *)
+
+let size_domainstate_args = 64 * size_int
+
+let calling_conventions
+    first_int last_int first_float last_float make_stack first_stack arg =
+  let loc = Array.make (Array.length arg) Reg.dummy in
+  let int = ref first_int in
+  let float = ref first_float in
+  let ofs = ref first_stack in
+  for i = 0 to Array.length arg - 1 do
+    match arg.(i) with
+    | Val | Int | Addr as ty ->
+        if !int <= last_int then begin
+          loc.(i) <- phys_reg !int;
+          incr int
+        end else begin
+          loc.(i) <- stack_slot (make_stack !ofs) ty;
+          ofs := !ofs + size_int
+        end
+    | Float ->
+        if !float <= last_float then begin
+          loc.(i) <- phys_reg !float;
+          incr float
+        end else begin
+          loc.(i) <- stack_slot (make_stack !ofs) Float;
+          ofs := !ofs + size_float
+        end
+  done;
+  (loc, Misc.align (max 0 !ofs) 16) (* Keep stack 16-aligned. *)
+
+let incoming ofs =
+  if ofs >= 0
+  then Incoming ofs
+  else Domainstate (ofs + size_domainstate_args)
+let outgoing ofs =
+  if ofs >= 0
+  then Outgoing ofs
+  else Domainstate (ofs + size_domainstate_args)
+let not_supported _ = fatal_error "Proc.loc_results: cannot call"
+
+let max_arguments_for_tailcalls = 13 (* in regs *) + 64 (* in domain state *)
+
+(* OCaml calling convention:
+     first integer args in a0 .. a7, s2 .. s6
+     first float args in fa0 .. fa7, fs2 .. fs9
+     remaining args in domain state area, then on stack.
+   Return values in a0 .. a7, s2 .. s6 or fa0 .. fa7, fs2 .. fs9. *)
+
+let loc_arguments arg =
+  calling_conventions 0 12 110 121 outgoing (- size_domainstate_args) arg
+
+let loc_parameters arg =
+  let (loc, _ofs) =
+    calling_conventions 0 12 110 121 incoming (- size_domainstate_args) arg
+  in
+  loc
+
+let loc_results res =
+  let (loc, _ofs) =
+    calling_conventions 0 12 110 121 not_supported 0 res
+  in
+  loc
+
+(* C calling convention:
+     first integer args in a0 .. a7
+     first float args in fa0 .. fa7
+     remaining args on stack.
+   A FP argument can be passed in an integer register if all FP registers
+   are exhausted but integer registers remain.
+   Return values in a0 .. a1 or fa0 .. fa1. *)
+
+let external_calling_conventions
+    first_int last_int first_float last_float make_stack arg =
+  let loc = Array.make (Array.length arg) [| Reg.dummy |] in
+  let int = ref first_int in
+  let float = ref first_float in
+  let ofs = ref 0 in
+  for i = 0 to Array.length arg - 1 do
+    match arg.(i) with
+    | Val | Int | Addr as ty ->
+        if !int <= last_int then begin
+          loc.(i) <- [| phys_reg !int |];
+          incr int
+        end else begin
+          loc.(i) <- [| stack_slot (make_stack !ofs) ty |];
+          ofs := !ofs + size_int
+        end
+    | Float ->
+        if !float <= last_float then begin
+          loc.(i) <- [| phys_reg !float |];
+          incr float
+        end else begin
+          loc.(i) <- [| stack_slot (make_stack !ofs) Float |];
+          ofs := !ofs + size_float
+        end
+  done;
+  (loc, Misc.align !ofs 16) (* Keep stack 16-aligned. *)
+
+let loc_external_arguments ty_args =
+  let arg = Cmm.machtype_of_exttype_list ty_args in
+  external_calling_conventions 0 7 110 117 outgoing arg
+
+let loc_external_results res =
+  let (loc, _ofs) = calling_conventions 0 1 110 111 not_supported 0 res
+  in loc
+
+(* Exceptions are in a0 *)
+
+let loc_exn_bucket = phys_reg 0
+
+(* Registers destroyed by operations *)
+
+let destroyed_at_c_noalloc_call =
+  (* s0-s8 and fs0-fs7 are callee-save, but s0 is
+     used to preserve OCaml sp. *)
+  Array.of_list(List.map phys_reg
+    [0; 1; 2; 3; 4; 5; 6; 7; 13; 14; 15; 16; 17; 18; 19; 20;(*s0*)
+     100; 101; 102; 103; 104; 105; 106; 107; 110; 111; 112; 113; 114; 115; 116;
+     117; 124; 125; 126; 127; 128; 129; 130; 131])
+
+let destroyed_at_alloc =
+  (* t0-t6 are used for PLT stubs *)
+    if !Clflags.dlcode then Array.map phys_reg [|13; 14; 15; 16; 17; 18; 19|]
+  else [| phys_reg 13 |] (* t2 is used to pass the argument to caml_allocN *)
+
+let destroyed_at_oper = function
+  | Iop(Icall_ind | Icall_imm _) -> all_phys_regs
+  | Iop(Iextcall{alloc; stack_ofs; _}) ->
+      assert (stack_ofs >= 0);
+      if alloc || stack_ofs > 0 then all_phys_regs
+      else destroyed_at_c_noalloc_call
+  | Iop(Ialloc _) | Iop(Ipoll _) -> destroyed_at_alloc
+  | Iop(Istore(Single, _, _)) -> [| phys_reg 100 |]
+  | Iop(Ifloatofint | Iintoffloat) -> [| phys_reg 100 |]
+  | _ -> [| |]
+
+let destroyed_at_raise = all_phys_regs
+
+let destroyed_at_reloadretaddr = [| |]
+
+(* Maximal register pressure *)
+
+let safe_register_pressure = function
+  | Iextcall _ -> 5  (*9-3 s0~s8 - s7 - s8 - s1 - s0*)
+  | _ -> 21
+
+let max_register_pressure = function
+  | Iextcall _ -> [| 5; 8 |] (* 6 integer callee-saves, 8 FP callee-saves *)
+  | _ -> [| 21; 30 |]
+
+(* Layout of the stack *)
+
+let frame_required fd =
+  fd.fun_contains_calls
+  || fd.fun_num_stack_slots.(0) > 0
+  || fd.fun_num_stack_slots.(1) > 0
+
+let prologue_required fd =
+  frame_required fd
+
+  (* FIXME *)
+let int_dwarf_reg_numbers =
+    [| 4; 5; 6; 7; 8; 9; 10; 11;
+     23; 24; 25; 26; 27; 28; 29; 30;
+     14; 15; 16; 17; 18;
+     31;
+     12; 13;
+     19; 20;
+  |]
+
+let float_dwarf_reg_numbers =
+  [| 32; 33; 34; 35; 36; 37; 38; 39;
+     40; 41;
+     42; 43; 44; 45; 46; 47; 48; 49;
+     50; 51; 52; 53; 54; 55; 56; 57;
+     58; 59;
+     60; 61; 62; 63;
+  |]
+
+let dwarf_register_numbers ~reg_class =
+  match reg_class with
+  | 0 -> int_dwarf_reg_numbers
+  | 1 -> float_dwarf_reg_numbers
+  | _ -> Misc.fatal_errorf "Bad register class %d" reg_class
+
+let stack_ptr_dwarf_register_number = 2
+
+(* Calling the assembler *)
+
+let assemble_file infile outfile =
+  Ccomp.command
+    (Config.asm ^ " -o " ^ Filename.quote outfile ^ " " ^ Filename.quote infile)
+
+let init () = ()
diff --git a/asmcomp/loongarch64/reload.ml b/asmcomp/loongarch64/reload.ml
new file mode 100644
index 0000000..a997f12
--- /dev/null
+++ b/asmcomp/loongarch64/reload.ml
@@ -0,0 +1,19 @@
+# 2 "asmcomp/loongarch64/reload.ml"
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*                yala <zhaojunchao@loongson.cn>                          *)
+(*                                                                        *)
+(*               Copyright © 2008-2023 LOONGSON                           *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Reloading for the LoongArch *)
+
+let fundecl f =
+  (new Reloadgen.reload_generic)#fundecl f
diff --git a/asmcomp/loongarch64/scheduling.ml b/asmcomp/loongarch64/scheduling.ml
new file mode 100644
index 0000000..86febf1
--- /dev/null
+++ b/asmcomp/loongarch64/scheduling.ml
@@ -0,0 +1,30 @@
+# 2 "asmcomp/loongarch64/scheduling.ml"
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*                yala <zhaojunchao@loongson.cn>                          *)
+(*                                                                        *)
+(*               Copyright © 2008-2023 LOONGSON                           *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Instruction scheduling for the LoongArch *)
+
+(* The "open!" directive below is necessary because, although
+   this module does not actually depend on Schedgen in this backend, the
+   dependency exists in other backends and our build system requires
+   that all the backends have the same dependencies.
+   We thus have to use "open!" and disable the corresponding warning
+   only for this compilation unit.
+*)
+
+open! Schedgen [@@warning "-66"]
+
+(* Scheduling is turned off. *)
+
+let fundecl f = f
diff --git a/asmcomp/loongarch64/selection.ml b/asmcomp/loongarch64/selection.ml
new file mode 100644
index 0000000..497faf5
--- /dev/null
+++ b/asmcomp/loongarch64/selection.ml
@@ -0,0 +1,68 @@
+# 2 "asmcomp/loongarch64/selection.ml"
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*                yala <zhaojunchao@loongson.cn>                          *)
+(*                                                                        *)
+(*               Copyright © 2008-2023 LOONGSON                           *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Instruction selection for the LoongArch processor *)
+
+open Cmm
+open Arch
+open Mach
+
+(* Instruction selection *)
+
+class selector = object
+
+inherit Selectgen.selector_generic as super
+
+(* LoongArch does not support immediate operands for comparison operators *)
+method is_immediate_test _cmp _n = false
+
+method! is_immediate op n =
+  match op with
+  | Iadd | Iand | Ior | Ixor -> is_immediate n
+  (* sub immediate is turned into add immediate opposite *)
+  | Isub -> is_immediate (-n)
+  | _ -> super#is_immediate op n
+
+method select_addressing _ = function
+  | Cop(Cadda, [arg; Cconst_int (n, _)], _) when is_immediate n ->
+      (Iindexed n, arg)
+  | Cop(Cadda, [arg1; Cop(Caddi, [arg2; Cconst_int (n, _)], _)], dbg)
+    when is_immediate n ->
+      (Iindexed n, Cop(Caddi, [arg1; arg2], dbg))
+  | arg ->
+      (Iindexed 0, arg)
+
+method! select_operation op args dbg =
+  match (op, args) with
+  (* Recognize (neg-)mult-add and (neg-)mult-sub instructions *)
+  | (Caddf, [Cop(Cmulf, [arg1; arg2], _); arg3])
+  | (Caddf, [arg3; Cop(Cmulf, [arg1; arg2], _)]) ->
+      (Ispecific (Imultaddf false), [arg1; arg2; arg3])
+  | (Csubf, [Cop(Cmulf, [arg1; arg2], _); arg3]) ->
+      (Ispecific (Imultsubf false), [arg1; arg2; arg3])
+  | (Cnegf, [Cop(Csubf, [Cop(Cmulf, [arg1; arg2], _); arg3], _)]) ->
+      (Ispecific (Imultsubf true), [arg1; arg2; arg3])
+  | (Cnegf, [Cop(Caddf, [Cop(Cmulf, [arg1; arg2], _); arg3], _)]) ->
+      (Ispecific (Imultaddf true), [arg1; arg2; arg3])
+  | (Cstore (Word_int | Word_val as memory_chunk, Assignment), [arg1; arg2]) ->
+      (* Use trivial addressing mode for non-initializing stores *)
+      (Istore (memory_chunk, Iindexed 0, true), [arg2; arg1])
+  | _ ->
+      super#select_operation op args dbg
+
+end
+
+let fundecl ~future_funcnames f =
+  (new selector)#emit_fundecl ~future_funcnames f
diff --git a/asmcomp/proc.mli b/asmcomp/proc.mli
index c1692c0..8912b28 100644
--- a/asmcomp/proc.mli
+++ b/asmcomp/proc.mli
@@ -56,7 +56,7 @@ val destroyed_at_raise: Reg.t array
 val destroyed_at_reloadretaddr : Reg.t array
 
 (* Volatile registers: those that change value when read *)
-val regs_are_volatile: Reg.t array -> bool
+(*val regs_are_volatile: Reg.t array -> bool *)
 
 (* Info for laying out the stack frame *)
 val frame_required : Mach.fundecl -> bool
diff --git a/build-aux/config.guess b/build-aux/config.guess
index e94095c..015efd1 100755
--- a/build-aux/config.guess
+++ b/build-aux/config.guess
@@ -1,8 +1,8 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright 1992-2020 Free Software Foundation, Inc.
+#   Copyright 1992-2018 Free Software Foundation, Inc.
 
-timestamp='2020-07-12'
+timestamp='2018-02-24'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -50,7 +50,7 @@ version="\
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright 1992-2020 Free Software Foundation, Inc.
+Copyright 1992-2018 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -84,6 +84,8 @@ if test $# != 0; then
   exit 1
 fi
 
+trap 'exit 1' 1 2 15
+
 # CC_FOR_BUILD -- compiler used by this script. Note that the use of a
 # compiler to aid in system detection is discouraged as it requires
 # temporary files to be created and, as you can see below, it is a
@@ -94,40 +96,34 @@ fi
 
 # Portable tmp directory creation inspired by the Autoconf team.
 
-tmp=
-# shellcheck disable=SC2172
-trap 'test -z "$tmp" || rm -fr "$tmp"' 0 1 2 13 15
-
-set_cc_for_build() {
-    # prevent multiple calls if $tmp is already set
-    test "$tmp" && return 0
-    : "${TMPDIR=/tmp}"
-    # shellcheck disable=SC2039
-    { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
-	{ test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir "$tmp" 2>/dev/null) ; } ||
-	{ tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir "$tmp" 2>/dev/null) && echo "Warning: creating insecure temp directory" >&2 ; } ||
-	{ echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; }
-    dummy=$tmp/dummy
-    case ${CC_FOR_BUILD-},${HOST_CC-},${CC-} in
-	,,)    echo "int x;" > "$dummy.c"
-	       for driver in cc gcc c89 c99 ; do
-		   if ($driver -c -o "$dummy.o" "$dummy.c") >/dev/null 2>&1 ; then
-		       CC_FOR_BUILD="$driver"
-		       break
-		   fi
-	       done
-	       if test x"$CC_FOR_BUILD" = x ; then
-		   CC_FOR_BUILD=no_compiler_found
-	       fi
-	       ;;
-	,,*)   CC_FOR_BUILD=$CC ;;
-	,*,*)  CC_FOR_BUILD=$HOST_CC ;;
-    esac
-}
+set_cc_for_build='
+trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
+trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
+: ${TMPDIR=/tmp} ;
+ { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
+ { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
+ { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
+ { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
+dummy=$tmp/dummy ;
+tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
+case $CC_FOR_BUILD,$HOST_CC,$CC in
+ ,,)    echo "int x;" > "$dummy.c" ;
+	for c in cc gcc c89 c99 ; do
+	  if ($c -c -o "$dummy.o" "$dummy.c") >/dev/null 2>&1 ; then
+	     CC_FOR_BUILD="$c"; break ;
+	  fi ;
+	done ;
+	if test x"$CC_FOR_BUILD" = x ; then
+	  CC_FOR_BUILD=no_compiler_found ;
+	fi
+	;;
+ ,,*)   CC_FOR_BUILD=$CC ;;
+ ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
+esac ; set_cc_for_build= ;'
 
 # This is needed to find uname on a Pyramid OSx when run in the BSD universe.
 # (ghazi@noc.rutgers.edu 1994-08-24)
-if test -f /.attbin/uname ; then
+if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
 	PATH=$PATH:/.attbin ; export PATH
 fi
 
@@ -142,7 +138,7 @@ Linux|GNU|GNU/*)
 	# We could probably try harder.
 	LIBC=gnu
 
-	set_cc_for_build
+	eval "$set_cc_for_build"
 	cat <<-EOF > "$dummy.c"
 	#include <features.h>
 	#if defined(__UCLIBC__)
@@ -203,7 +199,7 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 		os=netbsdelf
 		;;
 	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
-		set_cc_for_build
+		eval "$set_cc_for_build"
 		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
 			| grep -q __ELF__
 		then
@@ -241,7 +237,7 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
 	# contains redundant information, the shorter form:
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
-	echo "$machine-${os}${release}${abi-}"
+	echo "$machine-${os}${release}${abi}"
 	exit ;;
     *:Bitrig:*:*)
 	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
@@ -264,9 +260,6 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
     *:SolidBSD:*:*)
 	echo "$UNAME_MACHINE"-unknown-solidbsd"$UNAME_RELEASE"
 	exit ;;
-    *:OS108:*:*)
-	echo "$UNAME_MACHINE"-unknown-os108_"$UNAME_RELEASE"
-	exit ;;
     macppc:MirBSD:*:*)
 	echo powerpc-unknown-mirbsd"$UNAME_RELEASE"
 	exit ;;
@@ -276,15 +269,12 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
     *:Sortix:*:*)
 	echo "$UNAME_MACHINE"-unknown-sortix
 	exit ;;
-    *:Twizzler:*:*)
-	echo "$UNAME_MACHINE"-unknown-twizzler
-	exit ;;
     *:Redox:*:*)
 	echo "$UNAME_MACHINE"-unknown-redox
 	exit ;;
     mips:OSF1:*.*)
-	echo mips-dec-osf1
-	exit ;;
+        echo mips-dec-osf1
+        exit ;;
     alpha:OSF1:*:*)
 	case $UNAME_RELEASE in
 	*4.0)
@@ -399,7 +389,7 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 	echo i386-pc-auroraux"$UNAME_RELEASE"
 	exit ;;
     i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
-	set_cc_for_build
+	eval "$set_cc_for_build"
 	SUN_ARCH=i386
 	# If there is a compiler, see if it is configured for 64-bit objects.
 	# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.
@@ -492,7 +482,7 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 	echo clipper-intergraph-clix"$UNAME_RELEASE"
 	exit ;;
     mips:*:*:UMIPS | mips:*:*:RISCos)
-	set_cc_for_build
+	eval "$set_cc_for_build"
 	sed 's/^	//' << EOF > "$dummy.c"
 #ifdef __cplusplus
 #include <stdio.h>  /* for printf() prototype */
@@ -589,7 +579,7 @@ EOF
 	exit ;;
     *:AIX:2:3)
 	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
-		set_cc_for_build
+		eval "$set_cc_for_build"
 		sed 's/^		//' << EOF > "$dummy.c"
 		#include <sys/systemcfg.h>
 
@@ -670,7 +660,7 @@ EOF
 		    esac
 		fi
 		if [ "$HP_ARCH" = "" ]; then
-		    set_cc_for_build
+		    eval "$set_cc_for_build"
 		    sed 's/^		//' << EOF > "$dummy.c"
 
 		#define _HPUX_SOURCE
@@ -710,7 +700,7 @@ EOF
 	esac
 	if [ "$HP_ARCH" = hppa2.0w ]
 	then
-	    set_cc_for_build
+	    eval "$set_cc_for_build"
 
 	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
 	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
@@ -736,7 +726,7 @@ EOF
 	echo ia64-hp-hpux"$HPUX_REV"
 	exit ;;
     3050*:HI-UX:*:*)
-	set_cc_for_build
+	eval "$set_cc_for_build"
 	sed 's/^	//' << EOF > "$dummy.c"
 	#include <unistd.h>
 	int
@@ -850,17 +840,6 @@ EOF
     *:BSD/OS:*:*)
 	echo "$UNAME_MACHINE"-unknown-bsdi"$UNAME_RELEASE"
 	exit ;;
-    arm:FreeBSD:*:*)
-	UNAME_PROCESSOR=`uname -p`
-	set_cc_for_build
-	if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
-	    | grep -q __ARM_PCS_VFP
-	then
-	    echo "${UNAME_PROCESSOR}"-unknown-freebsd"`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`"-gnueabi
-	else
-	    echo "${UNAME_PROCESSOR}"-unknown-freebsd"`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`"-gnueabihf
-	fi
-	exit ;;
     *:FreeBSD:*:*)
 	UNAME_PROCESSOR=`/usr/bin/uname -p`
 	case "$UNAME_PROCESSOR" in
@@ -902,7 +881,7 @@ EOF
 	echo "$UNAME_MACHINE"-pc-uwin
 	exit ;;
     amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
-	echo x86_64-pc-cygwin
+	echo x86_64-unknown-cygwin
 	exit ;;
     prep*:SunOS:5.*:*)
 	echo powerpcle-unknown-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
@@ -915,8 +894,8 @@ EOF
 	# other systems with GNU libc and userland
 	echo "$UNAME_MACHINE-unknown-`echo "$UNAME_SYSTEM" | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]"``echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`-$LIBC"
 	exit ;;
-    *:Minix:*:*)
-	echo "$UNAME_MACHINE"-unknown-minix
+    i*86:Minix:*:*)
+	echo "$UNAME_MACHINE"-pc-minix
 	exit ;;
     aarch64:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
@@ -926,7 +905,7 @@ EOF
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     alpha:Linux:*:*)
-	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' /proc/cpuinfo 2>/dev/null` in
+	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
 	  EV5)   UNAME_MACHINE=alphaev5 ;;
 	  EV56)  UNAME_MACHINE=alphaev56 ;;
 	  PCA56) UNAME_MACHINE=alphapca56 ;;
@@ -943,7 +922,7 @@ EOF
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     arm*:Linux:*:*)
-	set_cc_for_build
+	eval "$set_cc_for_build"
 	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
 	    | grep -q __ARM_EABI__
 	then
@@ -985,6 +964,9 @@ EOF
     k1om:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
+    loongarch32:Linux:*:* | loongarch64:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
     m32r*:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
@@ -992,51 +974,23 @@ EOF
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     mips:Linux:*:* | mips64:Linux:*:*)
-	set_cc_for_build
-	IS_GLIBC=0
-	test x"${LIBC}" = xgnu && IS_GLIBC=1
+	eval "$set_cc_for_build"
 	sed 's/^	//' << EOF > "$dummy.c"
 	#undef CPU
-	#undef mips
-	#undef mipsel
-	#undef mips64
-	#undef mips64el
-	#if ${IS_GLIBC} && defined(_ABI64)
-	LIBCABI=gnuabi64
-	#else
-	#if ${IS_GLIBC} && defined(_ABIN32)
-	LIBCABI=gnuabin32
-	#else
-	LIBCABI=${LIBC}
-	#endif
-	#endif
-
-	#if ${IS_GLIBC} && defined(__mips64) && defined(__mips_isa_rev) && __mips_isa_rev>=6
-	CPU=mipsisa64r6
-	#else
-	#if ${IS_GLIBC} && !defined(__mips64) && defined(__mips_isa_rev) && __mips_isa_rev>=6
-	CPU=mipsisa32r6
-	#else
-	#if defined(__mips64)
-	CPU=mips64
-	#else
-	CPU=mips
-	#endif
-	#endif
-	#endif
-
+	#undef ${UNAME_MACHINE}
+	#undef ${UNAME_MACHINE}el
 	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
-	MIPS_ENDIAN=el
+	CPU=${UNAME_MACHINE}el
 	#else
 	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
-	MIPS_ENDIAN=
+	CPU=${UNAME_MACHINE}
 	#else
-	MIPS_ENDIAN=
+	CPU=
 	#endif
 	#endif
 EOF
-	eval "`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^CPU\|^MIPS_ENDIAN\|^LIBCABI'`"
-	test "x$CPU" != x && { echo "$CPU${MIPS_ENDIAN}-unknown-linux-$LIBCABI"; exit; }
+	eval "`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^CPU'`"
+	test "x$CPU" != x && { echo "$CPU-unknown-linux-$LIBC"; exit; }
 	;;
     mips64el:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
@@ -1095,17 +1049,11 @@ EOF
 	echo "$UNAME_MACHINE"-dec-linux-"$LIBC"
 	exit ;;
     x86_64:Linux:*:*)
-	set_cc_for_build
-	LIBCABI=$LIBC
-	if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
-	    if (echo '#ifdef __ILP32__'; echo IS_X32; echo '#endif') | \
-		(CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
-		grep IS_X32 >/dev/null
-	    then
-		LIBCABI="$LIBC"x32
-	    fi
+	if objdump -f /bin/sh | grep -q elf32-x86-64; then
+	    echo "$UNAME_MACHINE"-pc-linux-"$LIBC"x32
+	else
+	    echo "$UNAME_MACHINE"-pc-linux-"$LIBC"
 	fi
-	echo "$UNAME_MACHINE"-pc-linux-"$LIBCABI"
 	exit ;;
     xtensa*:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
@@ -1159,7 +1107,7 @@ EOF
 	    *Pentium)	     UNAME_MACHINE=i586 ;;
 	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
 	esac
-	echo "$UNAME_MACHINE-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}"
+	echo "$UNAME_MACHINE-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}{$UNAME_VERSION}"
 	exit ;;
     i*86:*:3.2:*)
 	if test -f /usr/options/cb.name; then
@@ -1342,43 +1290,39 @@ EOF
     *:Rhapsody:*:*)
 	echo "$UNAME_MACHINE"-apple-rhapsody"$UNAME_RELEASE"
 	exit ;;
-    arm64:Darwin:*:*)
-	echo aarch64-apple-darwin"$UNAME_RELEASE"
-	exit ;;
     *:Darwin:*:*)
-	UNAME_PROCESSOR=`uname -p`
-	case $UNAME_PROCESSOR in
-	    unknown) UNAME_PROCESSOR=powerpc ;;
-	esac
-	if command -v xcode-select > /dev/null 2> /dev/null && \
-		! xcode-select --print-path > /dev/null 2> /dev/null ; then
-	    # Avoid executing cc if there is no toolchain installed as
-	    # cc will be a stub that puts up a graphical alert
-	    # prompting the user to install developer tools.
-	    CC_FOR_BUILD=no_compiler_found
-	else
-	    set_cc_for_build
+	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
+	eval "$set_cc_for_build"
+	if test "$UNAME_PROCESSOR" = unknown ; then
+	    UNAME_PROCESSOR=powerpc
 	fi
-	if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
-	    if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
-		   (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
-		   grep IS_64BIT_ARCH >/dev/null
-	    then
-		case $UNAME_PROCESSOR in
-		    i386) UNAME_PROCESSOR=x86_64 ;;
-		    powerpc) UNAME_PROCESSOR=powerpc64 ;;
-		esac
-	    fi
-	    # On 10.4-10.6 one might compile for PowerPC via gcc -arch ppc
-	    if (echo '#ifdef __POWERPC__'; echo IS_PPC; echo '#endif') | \
-		   (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
-		   grep IS_PPC >/dev/null
-	    then
-		UNAME_PROCESSOR=powerpc
+	if test "`echo "$UNAME_RELEASE" | sed -e 's/\..*//'`" -le 10 ; then
+	    if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
+		if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		       (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		       grep IS_64BIT_ARCH >/dev/null
+		then
+		    case $UNAME_PROCESSOR in
+			i386) UNAME_PROCESSOR=x86_64 ;;
+			powerpc) UNAME_PROCESSOR=powerpc64 ;;
+		    esac
+		fi
+		# On 10.4-10.6 one might compile for PowerPC via gcc -arch ppc
+		if (echo '#ifdef __POWERPC__'; echo IS_PPC; echo '#endif') | \
+		       (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		       grep IS_PPC >/dev/null
+		then
+		    UNAME_PROCESSOR=powerpc
+		fi
 	    fi
 	elif test "$UNAME_PROCESSOR" = i386 ; then
-	    # uname -m returns i386 or x86_64
-	    UNAME_PROCESSOR=$UNAME_MACHINE
+	    # Avoid executing cc on OS X 10.9, as it ships with a stub
+	    # that puts up a graphical alert prompting to install
+	    # developer tools.  Any system running Mac OS X 10.7 or
+	    # later (Darwin 11 and later) is required to have a 64-bit
+	    # processor. This is not true of the ARM version of Darwin
+	    # that Apple uses in portable devices.
+	    UNAME_PROCESSOR=x86_64
 	fi
 	echo "$UNAME_PROCESSOR"-apple-darwin"$UNAME_RELEASE"
 	exit ;;
@@ -1421,7 +1365,6 @@ EOF
 	# "uname -m" is not consistent, so use $cputype instead. 386
 	# is converted to i386 for consistency with other x86
 	# operating systems.
-	# shellcheck disable=SC2154
 	if test "$cputype" = 386; then
 	    UNAME_MACHINE=i386
 	else
@@ -1478,148 +1421,8 @@ EOF
     amd64:Isilon\ OneFS:*:*)
 	echo x86_64-unknown-onefs
 	exit ;;
-    *:Unleashed:*:*)
-	echo "$UNAME_MACHINE"-unknown-unleashed"$UNAME_RELEASE"
-	exit ;;
 esac
 
-# No uname command or uname output not recognized.
-set_cc_for_build
-cat > "$dummy.c" <<EOF
-#ifdef _SEQUENT_
-#include <sys/types.h>
-#include <sys/utsname.h>
-#endif
-#if defined(ultrix) || defined(_ultrix) || defined(__ultrix) || defined(__ultrix__)
-#if defined (vax) || defined (__vax) || defined (__vax__) || defined(mips) || defined(__mips) || defined(__mips__) || defined(MIPS) || defined(__MIPS__)
-#include <signal.h>
-#if defined(_SIZE_T_) || defined(SIGLOST)
-#include <sys/utsname.h>
-#endif
-#endif
-#endif
-main ()
-{
-#if defined (sony)
-#if defined (MIPSEB)
-  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
-     I don't know....  */
-  printf ("mips-sony-bsd\n"); exit (0);
-#else
-#include <sys/param.h>
-  printf ("m68k-sony-newsos%s\n",
-#ifdef NEWSOS4
-  "4"
-#else
-  ""
-#endif
-  ); exit (0);
-#endif
-#endif
-
-#if defined (NeXT)
-#if !defined (__ARCHITECTURE__)
-#define __ARCHITECTURE__ "m68k"
-#endif
-  int version;
-  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
-  if (version < 4)
-    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
-  else
-    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
-  exit (0);
-#endif
-
-#if defined (MULTIMAX) || defined (n16)
-#if defined (UMAXV)
-  printf ("ns32k-encore-sysv\n"); exit (0);
-#else
-#if defined (CMU)
-  printf ("ns32k-encore-mach\n"); exit (0);
-#else
-  printf ("ns32k-encore-bsd\n"); exit (0);
-#endif
-#endif
-#endif
-
-#if defined (__386BSD__)
-  printf ("i386-pc-bsd\n"); exit (0);
-#endif
-
-#if defined (sequent)
-#if defined (i386)
-  printf ("i386-sequent-dynix\n"); exit (0);
-#endif
-#if defined (ns32000)
-  printf ("ns32k-sequent-dynix\n"); exit (0);
-#endif
-#endif
-
-#if defined (_SEQUENT_)
-  struct utsname un;
-
-  uname(&un);
-  if (strncmp(un.version, "V2", 2) == 0) {
-    printf ("i386-sequent-ptx2\n"); exit (0);
-  }
-  if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
-    printf ("i386-sequent-ptx1\n"); exit (0);
-  }
-  printf ("i386-sequent-ptx\n"); exit (0);
-#endif
-
-#if defined (vax)
-#if !defined (ultrix)
-#include <sys/param.h>
-#if defined (BSD)
-#if BSD == 43
-  printf ("vax-dec-bsd4.3\n"); exit (0);
-#else
-#if BSD == 199006
-  printf ("vax-dec-bsd4.3reno\n"); exit (0);
-#else
-  printf ("vax-dec-bsd\n"); exit (0);
-#endif
-#endif
-#else
-  printf ("vax-dec-bsd\n"); exit (0);
-#endif
-#else
-#if defined(_SIZE_T_) || defined(SIGLOST)
-  struct utsname un;
-  uname (&un);
-  printf ("vax-dec-ultrix%s\n", un.release); exit (0);
-#else
-  printf ("vax-dec-ultrix\n"); exit (0);
-#endif
-#endif
-#endif
-#if defined(ultrix) || defined(_ultrix) || defined(__ultrix) || defined(__ultrix__)
-#if defined(mips) || defined(__mips) || defined(__mips__) || defined(MIPS) || defined(__MIPS__)
-#if defined(_SIZE_T_) || defined(SIGLOST)
-  struct utsname *un;
-  uname (&un);
-  printf ("mips-dec-ultrix%s\n", un.release); exit (0);
-#else
-  printf ("mips-dec-ultrix\n"); exit (0);
-#endif
-#endif
-#endif
-
-#if defined (alliant) && defined (i860)
-  printf ("i860-alliant-bsd\n"); exit (0);
-#endif
-
-  exit (1);
-}
-EOF
-
-$CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null && SYSTEM_NAME=`$dummy` &&
-	{ echo "$SYSTEM_NAME"; exit; }
-
-# Apollos put the system type in the environment.
-test -d /usr/apollo && { echo "$ISP-apollo-$SYSTYPE"; exit; }
-
 echo "$0: unable to guess system type" >&2
 
 case "$UNAME_MACHINE:$UNAME_SYSTEM" in
@@ -1642,12 +1445,6 @@ copies of config.guess and config.sub with the latest versions from:
   https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
 and
   https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
-EOF
-
-year=`echo $timestamp | sed 's,-.*,,'`
-# shellcheck disable=SC2003
-if test "`expr "\`date +%Y\`" - "$year"`" -lt 3 ; then
-   cat >&2 <<EOF
 
 If $0 has already been updated, send the following data and any
 information you think might be pertinent to config-patches@gnu.org to
@@ -1675,12 +1472,11 @@ UNAME_RELEASE = "$UNAME_RELEASE"
 UNAME_SYSTEM  = "$UNAME_SYSTEM"
 UNAME_VERSION = "$UNAME_VERSION"
 EOF
-fi
 
 exit 1
 
 # Local variables:
-# eval: (add-hook 'before-save-hook 'time-stamp)
+# eval: (add-hook 'write-file-functions 'time-stamp)
 # time-stamp-start: "timestamp='"
 # time-stamp-format: "%:y-%02m-%02d"
 # time-stamp-end: "'"
diff --git a/build-aux/config.sub b/build-aux/config.sub
index 3d9a8dc..682f597 100755
--- a/build-aux/config.sub
+++ b/build-aux/config.sub
@@ -1,8 +1,8 @@
 #! /bin/sh
 # Configuration validation subroutine script.
-#   Copyright 1992-2020 Free Software Foundation, Inc.
+#   Copyright 1992-2018 Free Software Foundation, Inc.
 
-timestamp='2020-07-10'
+timestamp='2018-02-22'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -67,7 +67,7 @@ Report bugs and patches to <config-patches@gnu.org>."
 version="\
 GNU config.sub ($timestamp)
 
-Copyright 1992-2020 Free Software Foundation, Inc.
+Copyright 1992-2018 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -89,7 +89,7 @@ while test $# -gt 0 ; do
     - )	# Use stdin as input.
        break ;;
     -* )
-       echo "$me: invalid option $1$help" >&2
+       echo "$me: invalid option $1$help"
        exit 1 ;;
 
     *local*)
@@ -110,1167 +110,1225 @@ case $# in
     exit 1;;
 esac
 
-# Split fields of configuration type
-# shellcheck disable=SC2162
-IFS="-" read field1 field2 field3 field4 <<EOF
-$1
-EOF
+# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
+# Here we must recognize all the valid KERNEL-OS combinations.
+maybe_os=`echo "$1" | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
+case $maybe_os in
+  nto-qnx* | linux-gnu* | linux-android* | linux-dietlibc | linux-newlib* | \
+  linux-musl* | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \
+  knetbsd*-gnu* | netbsd*-gnu* | netbsd*-eabi* | \
+  kopensolaris*-gnu* | cloudabi*-eabi* | \
+  storm-chaos* | os2-emx* | rtmk-nova*)
+    os=-$maybe_os
+    basic_machine=`echo "$1" | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
+    ;;
+  android-linux)
+    os=-linux-android
+    basic_machine=`echo "$1" | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`-unknown
+    ;;
+  *)
+    basic_machine=`echo "$1" | sed 's/-[^-]*$//'`
+    if [ "$basic_machine" != "$1" ]
+    then os=`echo "$1" | sed 's/.*-/-/'`
+    else os=; fi
+    ;;
+esac
 
-# Separate into logical components for further validation
-case $1 in
-	*-*-*-*-*)
-		echo Invalid configuration \`"$1"\': more than four components >&2
-		exit 1
+### Let's recognize common machines as not being operating systems so
+### that things like config.sub decstation-3100 work.  We also
+### recognize some manufacturers as not being operating systems, so we
+### can provide default operating systems below.
+case $os in
+	-sun*os*)
+		# Prevent following clause from handling this invalid input.
 		;;
-	*-*-*-*)
-		basic_machine=$field1-$field2
-		basic_os=$field3-$field4
+	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
+	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
+	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
+	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
+	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
+	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
+	-apple | -axis | -knuth | -cray | -microblaze* | loongson)
+		os=
+		basic_machine=$1
 		;;
-	*-*-*)
-		# Ambiguous whether COMPANY is present, or skipped and KERNEL-OS is two
-		# parts
-		maybe_os=$field2-$field3
-		case $maybe_os in
-			nto-qnx* | linux-* | uclinux-uclibc* \
-			| uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* \
-			| netbsd*-eabi* | kopensolaris*-gnu* | cloudabi*-eabi* \
-			| storm-chaos* | os2-emx* | rtmk-nova*)
-				basic_machine=$field1
-				basic_os=$maybe_os
-				;;
-			android-linux)
-				basic_machine=$field1-unknown
-				basic_os=linux-android
-				;;
-			*)
-				basic_machine=$field1-$field2
-				basic_os=$field3
-				;;
-		esac
+	-bluegene*)
+		os=-cnk
 		;;
-	*-*)
-		# A lone config we happen to match not fitting any pattern
-		case $field1-$field2 in
-			decstation-3100)
-				basic_machine=mips-dec
-				basic_os=
-				;;
-			*-*)
-				# Second component is usually, but not always the OS
-				case $field2 in
-					# Prevent following clause from handling this valid os
-					sun*os*)
-						basic_machine=$field1
-						basic_os=$field2
-						;;
-					# Manufacturers
-					dec* | mips* | sequent* | encore* | pc533* | sgi* | sony* \
-					| att* | 7300* | 3300* | delta* | motorola* | sun[234]* \
-					| unicom* | ibm* | next | hp | isi* | apollo | altos* \
-					| convergent* | ncr* | news | 32* | 3600* | 3100* \
-					| hitachi* | c[123]* | convex* | sun | crds | omron* | dg \
-					| ultra | tti* | harris | dolphin | highlevel | gould \
-					| cbm | ns | masscomp | apple | axis | knuth | cray \
-					| microblaze* | sim | cisco \
-					| oki | wec | wrs | winbond)
-						basic_machine=$field1-$field2
-						basic_os=
-						;;
-					*)
-						basic_machine=$field1
-						basic_os=$field2
-						;;
-				esac
-			;;
-		esac
+	-sim | -cisco | -oki | -wec | -winbond)
+		os=
+		basic_machine=$1
 		;;
-	*)
-		# Convert single-component short-hands not valid as part of
-		# multi-component configurations.
-		case $field1 in
-			386bsd)
-				basic_machine=i386-pc
-				basic_os=bsd
-				;;
-			a29khif)
-				basic_machine=a29k-amd
-				basic_os=udi
-				;;
-			adobe68k)
-				basic_machine=m68010-adobe
-				basic_os=scout
-				;;
-			alliant)
-				basic_machine=fx80-alliant
-				basic_os=
-				;;
-			altos | altos3068)
-				basic_machine=m68k-altos
-				basic_os=
-				;;
-			am29k)
-				basic_machine=a29k-none
-				basic_os=bsd
-				;;
-			amdahl)
-				basic_machine=580-amdahl
-				basic_os=sysv
-				;;
-			amiga)
-				basic_machine=m68k-unknown
-				basic_os=
-				;;
-			amigaos | amigados)
-				basic_machine=m68k-unknown
-				basic_os=amigaos
-				;;
-			amigaunix | amix)
-				basic_machine=m68k-unknown
-				basic_os=sysv4
-				;;
-			apollo68)
-				basic_machine=m68k-apollo
-				basic_os=sysv
-				;;
-			apollo68bsd)
-				basic_machine=m68k-apollo
-				basic_os=bsd
-				;;
-			aros)
-				basic_machine=i386-pc
-				basic_os=aros
-				;;
-			aux)
-				basic_machine=m68k-apple
-				basic_os=aux
-				;;
-			balance)
-				basic_machine=ns32k-sequent
-				basic_os=dynix
-				;;
-			blackfin)
-				basic_machine=bfin-unknown
-				basic_os=linux
-				;;
-			cegcc)
-				basic_machine=arm-unknown
-				basic_os=cegcc
-				;;
-			convex-c1)
-				basic_machine=c1-convex
-				basic_os=bsd
-				;;
-			convex-c2)
-				basic_machine=c2-convex
-				basic_os=bsd
-				;;
-			convex-c32)
-				basic_machine=c32-convex
-				basic_os=bsd
-				;;
-			convex-c34)
-				basic_machine=c34-convex
-				basic_os=bsd
-				;;
-			convex-c38)
-				basic_machine=c38-convex
-				basic_os=bsd
-				;;
-			cray)
-				basic_machine=j90-cray
-				basic_os=unicos
-				;;
-			crds | unos)
-				basic_machine=m68k-crds
-				basic_os=
-				;;
-			da30)
-				basic_machine=m68k-da30
-				basic_os=
-				;;
-			decstation | pmax | pmin | dec3100 | decstatn)
-				basic_machine=mips-dec
-				basic_os=
-				;;
-			delta88)
-				basic_machine=m88k-motorola
-				basic_os=sysv3
-				;;
-			dicos)
-				basic_machine=i686-pc
-				basic_os=dicos
-				;;
-			djgpp)
-				basic_machine=i586-pc
-				basic_os=msdosdjgpp
-				;;
-			ebmon29k)
-				basic_machine=a29k-amd
-				basic_os=ebmon
-				;;
-			es1800 | OSE68k | ose68k | ose | OSE)
-				basic_machine=m68k-ericsson
-				basic_os=ose
-				;;
-			gmicro)
-				basic_machine=tron-gmicro
-				basic_os=sysv
-				;;
-			go32)
-				basic_machine=i386-pc
-				basic_os=go32
-				;;
-			h8300hms)
-				basic_machine=h8300-hitachi
-				basic_os=hms
-				;;
-			h8300xray)
-				basic_machine=h8300-hitachi
-				basic_os=xray
-				;;
-			h8500hms)
-				basic_machine=h8500-hitachi
-				basic_os=hms
-				;;
-			harris)
-				basic_machine=m88k-harris
-				basic_os=sysv3
-				;;
-			hp300 | hp300hpux)
-				basic_machine=m68k-hp
-				basic_os=hpux
-				;;
-			hp300bsd)
-				basic_machine=m68k-hp
-				basic_os=bsd
-				;;
-			hppaosf)
-				basic_machine=hppa1.1-hp
-				basic_os=osf
-				;;
-			hppro)
-				basic_machine=hppa1.1-hp
-				basic_os=proelf
-				;;
-			i386mach)
-				basic_machine=i386-mach
-				basic_os=mach
-				;;
-			isi68 | isi)
-				basic_machine=m68k-isi
-				basic_os=sysv
-				;;
-			m68knommu)
-				basic_machine=m68k-unknown
-				basic_os=linux
-				;;
-			magnum | m3230)
-				basic_machine=mips-mips
-				basic_os=sysv
-				;;
-			merlin)
-				basic_machine=ns32k-utek
-				basic_os=sysv
-				;;
-			mingw64)
-				basic_machine=x86_64-pc
-				basic_os=mingw64
-				;;
-			mingw32)
-				basic_machine=i686-pc
-				basic_os=mingw32
-				;;
-			mingw32ce)
-				basic_machine=arm-unknown
-				basic_os=mingw32ce
-				;;
-			monitor)
-				basic_machine=m68k-rom68k
-				basic_os=coff
-				;;
-			morphos)
-				basic_machine=powerpc-unknown
-				basic_os=morphos
-				;;
-			moxiebox)
-				basic_machine=moxie-unknown
-				basic_os=moxiebox
-				;;
-			msdos)
-				basic_machine=i386-pc
-				basic_os=msdos
-				;;
-			msys)
-				basic_machine=i686-pc
-				basic_os=msys
-				;;
-			mvs)
-				basic_machine=i370-ibm
-				basic_os=mvs
-				;;
-			nacl)
-				basic_machine=le32-unknown
-				basic_os=nacl
-				;;
-			ncr3000)
-				basic_machine=i486-ncr
-				basic_os=sysv4
-				;;
-			netbsd386)
-				basic_machine=i386-pc
-				basic_os=netbsd
-				;;
-			netwinder)
-				basic_machine=armv4l-rebel
-				basic_os=linux
-				;;
-			news | news700 | news800 | news900)
-				basic_machine=m68k-sony
-				basic_os=newsos
-				;;
-			news1000)
-				basic_machine=m68030-sony
-				basic_os=newsos
-				;;
-			necv70)
-				basic_machine=v70-nec
-				basic_os=sysv
-				;;
-			nh3000)
-				basic_machine=m68k-harris
-				basic_os=cxux
-				;;
-			nh[45]000)
-				basic_machine=m88k-harris
-				basic_os=cxux
-				;;
-			nindy960)
-				basic_machine=i960-intel
-				basic_os=nindy
-				;;
-			mon960)
-				basic_machine=i960-intel
-				basic_os=mon960
-				;;
-			nonstopux)
-				basic_machine=mips-compaq
-				basic_os=nonstopux
-				;;
-			os400)
-				basic_machine=powerpc-ibm
-				basic_os=os400
-				;;
-			OSE68000 | ose68000)
-				basic_machine=m68000-ericsson
-				basic_os=ose
-				;;
-			os68k)
-				basic_machine=m68k-none
-				basic_os=os68k
-				;;
-			paragon)
-				basic_machine=i860-intel
-				basic_os=osf
-				;;
-			parisc)
-				basic_machine=hppa-unknown
-				basic_os=linux
-				;;
-			psp)
-				basic_machine=mipsallegrexel-sony
-				basic_os=psp
-				;;
-			pw32)
-				basic_machine=i586-unknown
-				basic_os=pw32
-				;;
-			rdos | rdos64)
-				basic_machine=x86_64-pc
-				basic_os=rdos
-				;;
-			rdos32)
-				basic_machine=i386-pc
-				basic_os=rdos
-				;;
-			rom68k)
-				basic_machine=m68k-rom68k
-				basic_os=coff
-				;;
-			sa29200)
-				basic_machine=a29k-amd
-				basic_os=udi
-				;;
-			sei)
-				basic_machine=mips-sei
-				basic_os=seiux
-				;;
-			sequent)
-				basic_machine=i386-sequent
-				basic_os=
-				;;
-			sps7)
-				basic_machine=m68k-bull
-				basic_os=sysv2
-				;;
-			st2000)
-				basic_machine=m68k-tandem
-				basic_os=
-				;;
-			stratus)
-				basic_machine=i860-stratus
-				basic_os=sysv4
-				;;
-			sun2)
-				basic_machine=m68000-sun
-				basic_os=
-				;;
-			sun2os3)
-				basic_machine=m68000-sun
-				basic_os=sunos3
-				;;
-			sun2os4)
-				basic_machine=m68000-sun
-				basic_os=sunos4
-				;;
-			sun3)
-				basic_machine=m68k-sun
-				basic_os=
-				;;
-			sun3os3)
-				basic_machine=m68k-sun
-				basic_os=sunos3
-				;;
-			sun3os4)
-				basic_machine=m68k-sun
-				basic_os=sunos4
-				;;
-			sun4)
-				basic_machine=sparc-sun
-				basic_os=
-				;;
-			sun4os3)
-				basic_machine=sparc-sun
-				basic_os=sunos3
-				;;
-			sun4os4)
-				basic_machine=sparc-sun
-				basic_os=sunos4
-				;;
-			sun4sol2)
-				basic_machine=sparc-sun
-				basic_os=solaris2
-				;;
-			sun386 | sun386i | roadrunner)
-				basic_machine=i386-sun
-				basic_os=
-				;;
-			sv1)
-				basic_machine=sv1-cray
-				basic_os=unicos
-				;;
-			symmetry)
-				basic_machine=i386-sequent
-				basic_os=dynix
-				;;
-			t3e)
-				basic_machine=alphaev5-cray
-				basic_os=unicos
-				;;
-			t90)
-				basic_machine=t90-cray
-				basic_os=unicos
-				;;
-			toad1)
-				basic_machine=pdp10-xkl
-				basic_os=tops20
-				;;
-			tpf)
-				basic_machine=s390x-ibm
-				basic_os=tpf
-				;;
-			udi29k)
-				basic_machine=a29k-amd
-				basic_os=udi
-				;;
-			ultra3)
-				basic_machine=a29k-nyu
-				basic_os=sym1
-				;;
-			v810 | necv810)
-				basic_machine=v810-nec
-				basic_os=none
-				;;
-			vaxv)
-				basic_machine=vax-dec
-				basic_os=sysv
-				;;
-			vms)
-				basic_machine=vax-dec
-				basic_os=vms
-				;;
-			vsta)
-				basic_machine=i386-pc
-				basic_os=vsta
-				;;
-			vxworks960)
-				basic_machine=i960-wrs
-				basic_os=vxworks
-				;;
-			vxworks68)
-				basic_machine=m68k-wrs
-				basic_os=vxworks
-				;;
-			vxworks29k)
-				basic_machine=a29k-wrs
-				basic_os=vxworks
-				;;
-			xbox)
-				basic_machine=i686-pc
-				basic_os=mingw32
-				;;
-			ymp)
-				basic_machine=ymp-cray
-				basic_os=unicos
-				;;
-			*)
-				basic_machine=$1
-				basic_os=
-				;;
-		esac
+	-scout)
+		;;
+	-wrs)
+		os=-vxworks
+		basic_machine=$1
+		;;
+	-chorusos*)
+		os=-chorusos
+		basic_machine=$1
+		;;
+	-chorusrdb)
+		os=-chorusrdb
+		basic_machine=$1
+		;;
+	-hiux*)
+		os=-hiuxwe2
+		;;
+	-sco6)
+		os=-sco5v6
+		basic_machine=`echo "$1" | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco5)
+		os=-sco3.2v5
+		basic_machine=`echo "$1" | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco4)
+		os=-sco3.2v4
+		basic_machine=`echo "$1" | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco3.2.[4-9]*)
+		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
+		basic_machine=`echo "$1" | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco3.2v[4-9]*)
+		# Don't forget version if it is 3.2v4 or newer.
+		basic_machine=`echo "$1" | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco5v6*)
+		# Don't forget version if it is 3.2v4 or newer.
+		basic_machine=`echo "$1" | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco*)
+		os=-sco3.2v2
+		basic_machine=`echo "$1" | sed -e 's/86-.*/86-pc/'`
+		;;
+	-udk*)
+		basic_machine=`echo "$1" | sed -e 's/86-.*/86-pc/'`
+		;;
+	-isc)
+		os=-isc2.2
+		basic_machine=`echo "$1" | sed -e 's/86-.*/86-pc/'`
+		;;
+	-clix*)
+		basic_machine=clipper-intergraph
+		;;
+	-isc*)
+		basic_machine=`echo "$1" | sed -e 's/86-.*/86-pc/'`
+		;;
+	-lynx*178)
+		os=-lynxos178
+		;;
+	-lynx*5)
+		os=-lynxos5
+		;;
+	-lynx*)
+		os=-lynxos
+		;;
+	-ptx*)
+		basic_machine=`echo "$1" | sed -e 's/86-.*/86-sequent/'`
+		;;
+	-psos*)
+		os=-psos
+		;;
+	-mint | -mint[0-9]*)
+		basic_machine=m68k-atari
+		os=-mint
 		;;
 esac
 
-# Decode 1-component or ad-hoc basic machines
+# Decode aliases for certain CPU-COMPANY combinations.
 case $basic_machine in
-	# Here we handle the default manufacturer of certain CPU types.  It is in
-	# some cases the only manufacturer, in others, it is the most popular.
-	w89k)
-		cpu=hppa1.1
-		vendor=winbond
+	# Recognize the basic CPU types without company name.
+	# Some are omitted here because they have special meanings below.
+	1750a | 580 \
+	| a29k \
+	| aarch64 | aarch64_be \
+	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
+	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
+	| am33_2.0 \
+	| arc | arceb \
+	| arm | arm[bl]e | arme[lb] | armv[2-8] | armv[3-8][lb] | armv7[arm] \
+	| avr | avr32 \
+	| ba \
+	| be32 | be64 \
+	| bfin \
+	| c4x | c8051 | clipper \
+	| d10v | d30v | dlx | dsp16xx \
+	| e2k | epiphany \
+	| fido | fr30 | frv | ft32 \
+	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
+	| hexagon \
+	| i370 | i860 | i960 | ia16 | ia64 \
+	| ip2k | iq2000 \
+	| k1om \
+	| le32 | le64 \
+	| lm32 \
+	| m32c | m32r | m32rle | m68000 | m68k | m88k \
+	| maxq | mb | microblaze | microblazeel | mcore | mep | metag \
+	| mips | mipsbe | mipseb | mipsel | mipsle \
+	| mips16 \
+	| mips64 | mips64el \
+	| mips64octeon | mips64octeonel \
+	| mips64orion | mips64orionel \
+	| mips64r5900 | mips64r5900el \
+	| mips64vr | mips64vrel \
+	| mips64vr4100 | mips64vr4100el \
+	| mips64vr4300 | mips64vr4300el \
+	| mips64vr5000 | mips64vr5000el \
+	| mips64vr5900 | mips64vr5900el \
+	| mipsisa32 | mipsisa32el \
+	| mipsisa32r2 | mipsisa32r2el \
+	| mipsisa32r6 | mipsisa32r6el \
+	| mipsisa64 | mipsisa64el \
+	| mipsisa64r2 | mipsisa64r2el \
+	| mipsisa64r6 | mipsisa64r6el \
+	| mipsisa64sb1 | mipsisa64sb1el \
+	| mipsisa64sr71k | mipsisa64sr71kel \
+	| mipsr5900 | mipsr5900el \
+	| mipstx39 | mipstx39el \
+	| mn10200 | mn10300 \
+	| moxie \
+	| mt \
+	| msp430 \
+	| loongarch32 | loongarch64 \
+	| nds32 | nds32le | nds32be \
+	| nios | nios2 | nios2eb | nios2el \
+	| ns16k | ns32k \
+	| open8 | or1k | or1knd | or32 \
+	| pdp10 | pj | pjl \
+	| powerpc | powerpc64 | powerpc64le | powerpcle \
+	| pru \
+	| pyramid \
+	| riscv32 | riscv64 \
+	| rl78 | rx \
+	| score \
+	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[234]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
+	| sh64 | sh64le \
+	| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \
+	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
+	| spu \
+	| tahoe | tic4x | tic54x | tic55x | tic6x | tic80 | tron \
+	| ubicom32 \
+	| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \
+	| visium \
+	| wasm32 \
+	| x86 | xc16x | xstormy16 | xtensa \
+	| z8k | z80)
+		basic_machine=$basic_machine-unknown
+		;;
+	c54x)
+		basic_machine=tic54x-unknown
+		;;
+	c55x)
+		basic_machine=tic55x-unknown
+		;;
+	c6x)
+		basic_machine=tic6x-unknown
 		;;
-	op50n)
-		cpu=hppa1.1
-		vendor=oki
+	leon|leon[3-9])
+		basic_machine=sparc-$basic_machine
 		;;
-	op60c)
-		cpu=hppa1.1
-		vendor=oki
+	m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x | nvptx | picochip)
+		basic_machine=$basic_machine-unknown
+		os=-none
 		;;
-	ibm*)
-		cpu=i370
-		vendor=ibm
+	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65)
 		;;
-	orion105)
-		cpu=clipper
-		vendor=highlevel
+	ms1)
+		basic_machine=mt-unknown
 		;;
-	mac | mpw | mac-mpw)
-		cpu=m68k
-		vendor=apple
+
+	strongarm | thumb | xscale)
+		basic_machine=arm-unknown
 		;;
-	pmac | pmac-mpw)
-		cpu=powerpc
-		vendor=apple
+	xgate)
+		basic_machine=$basic_machine-unknown
+		os=-none
+		;;
+	xscaleeb)
+		basic_machine=armeb-unknown
+		;;
+
+	xscaleel)
+		basic_machine=armel-unknown
 		;;
 
+	# We use `pc' rather than `unknown'
+	# because (1) that's what they normally are, and
+	# (2) the word "unknown" tends to confuse beginning users.
+	i*86 | x86_64)
+	  basic_machine=$basic_machine-pc
+	  ;;
+	# Object if more than one company name word.
+	*-*-*)
+		echo Invalid configuration \`"$1"\': machine \`"$basic_machine"\' not recognized 1>&2
+		exit 1
+		;;
+	# Recognize the basic CPU types with company name.
+	580-* \
+	| a29k-* \
+	| aarch64-* | aarch64_be-* \
+	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
+	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
+	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* | arceb-* \
+	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
+	| avr-* | avr32-* \
+	| ba-* \
+	| be32-* | be64-* \
+	| bfin-* | bs2000-* \
+	| c[123]* | c30-* | [cjt]90-* | c4x-* \
+	| c8051-* | clipper-* | craynv-* | cydra-* \
+	| d10v-* | d30v-* | dlx-* \
+	| e2k-* | elxsi-* \
+	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
+	| h8300-* | h8500-* \
+	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
+	| hexagon-* \
+	| i*86-* | i860-* | i960-* | ia16-* | ia64-* \
+	| ip2k-* | iq2000-* \
+	| k1om-* \
+	| le32-* | le64-* \
+	| loongarch32-* | loongarch64-* \
+	| lm32-* \
+	| m32c-* | m32r-* | m32rle-* \
+	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
+	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* \
+	| microblaze-* | microblazeel-* \
+	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
+	| mips16-* \
+	| mips64-* | mips64el-* \
+	| mips64octeon-* | mips64octeonel-* \
+	| mips64orion-* | mips64orionel-* \
+	| mips64r5900-* | mips64r5900el-* \
+	| mips64vr-* | mips64vrel-* \
+	| mips64vr4100-* | mips64vr4100el-* \
+	| mips64vr4300-* | mips64vr4300el-* \
+	| mips64vr5000-* | mips64vr5000el-* \
+	| mips64vr5900-* | mips64vr5900el-* \
+	| mipsisa32-* | mipsisa32el-* \
+	| mipsisa32r2-* | mipsisa32r2el-* \
+	| mipsisa32r6-* | mipsisa32r6el-* \
+	| mipsisa64-* | mipsisa64el-* \
+	| mipsisa64r2-* | mipsisa64r2el-* \
+	| mipsisa64r6-* | mipsisa64r6el-* \
+	| mipsisa64sb1-* | mipsisa64sb1el-* \
+	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
+	| mipsr5900-* | mipsr5900el-* \
+	| mipstx39-* | mipstx39el-* \
+	| mmix-* \
+	| mt-* \
+	| msp430-* \
+	| nds32-* | nds32le-* | nds32be-* \
+	| nios-* | nios2-* | nios2eb-* | nios2el-* \
+	| none-* | np1-* | ns16k-* | ns32k-* \
+	| open8-* \
+	| or1k*-* \
+	| orion-* \
+	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
+	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* \
+	| pru-* \
+	| pyramid-* \
+	| riscv32-* | riscv64-* \
+	| rl78-* | romp-* | rs6000-* | rx-* \
+	| sh-* | sh[1234]-* | sh[24]a-* | sh[24]aeb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
+	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
+	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
+	| sparclite-* \
+	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | sv1-* | sx*-* \
+	| tahoe-* \
+	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
+	| tile*-* \
+	| tron-* \
+	| ubicom32-* \
+	| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \
+	| vax-* \
+	| visium-* \
+	| wasm32-* \
+	| we32k-* \
+	| x86-* | x86_64-* | xc16x-* | xps100-* \
+	| xstormy16-* | xtensa*-* \
+	| ymp-* \
+	| z8k-* | z80-*)
+		;;
+	# Recognize the basic CPU types without company name, with glob match.
+	xtensa*)
+		basic_machine=$basic_machine-unknown
+		;;
 	# Recognize the various machine names and aliases which stand
 	# for a CPU type and a company and sometimes even an OS.
+	386bsd)
+		basic_machine=i386-pc
+		os=-bsd
+		;;
 	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
-		cpu=m68000
-		vendor=att
+		basic_machine=m68000-att
 		;;
 	3b*)
-		cpu=we32k
-		vendor=att
+		basic_machine=we32k-att
+		;;
+	a29khif)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+	abacus)
+		basic_machine=abacus-unknown
+		;;
+	adobe68k)
+		basic_machine=m68010-adobe
+		os=-scout
+		;;
+	alliant | fx80)
+		basic_machine=fx80-alliant
+		;;
+	altos | altos3068)
+		basic_machine=m68k-altos
+		;;
+	am29k)
+		basic_machine=a29k-none
+		os=-bsd
+		;;
+	amd64)
+		basic_machine=x86_64-pc
+		;;
+	amd64-*)
+		basic_machine=x86_64-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		;;
+	amdahl)
+		basic_machine=580-amdahl
+		os=-sysv
+		;;
+	amiga | amiga-*)
+		basic_machine=m68k-unknown
+		;;
+	amigaos | amigados)
+		basic_machine=m68k-unknown
+		os=-amigaos
+		;;
+	amigaunix | amix)
+		basic_machine=m68k-unknown
+		os=-sysv4
+		;;
+	apollo68)
+		basic_machine=m68k-apollo
+		os=-sysv
+		;;
+	apollo68bsd)
+		basic_machine=m68k-apollo
+		os=-bsd
+		;;
+	aros)
+		basic_machine=i386-pc
+		os=-aros
+		;;
+	asmjs)
+		basic_machine=asmjs-unknown
+		;;
+	aux)
+		basic_machine=m68k-apple
+		os=-aux
+		;;
+	balance)
+		basic_machine=ns32k-sequent
+		os=-dynix
+		;;
+	blackfin)
+		basic_machine=bfin-unknown
+		os=-linux
+		;;
+	blackfin-*)
+		basic_machine=bfin-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		os=-linux
 		;;
 	bluegene*)
-		cpu=powerpc
-		vendor=ibm
-		basic_os=cnk
+		basic_machine=powerpc-ibm
+		os=-cnk
+		;;
+	c54x-*)
+		basic_machine=tic54x-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		;;
+	c55x-*)
+		basic_machine=tic55x-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		;;
+	c6x-*)
+		basic_machine=tic6x-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		;;
+	c90)
+		basic_machine=c90-cray
+		os=-unicos
+		;;
+	cegcc)
+		basic_machine=arm-unknown
+		os=-cegcc
+		;;
+	convex-c1)
+		basic_machine=c1-convex
+		os=-bsd
+		;;
+	convex-c2)
+		basic_machine=c2-convex
+		os=-bsd
+		;;
+	convex-c32)
+		basic_machine=c32-convex
+		os=-bsd
+		;;
+	convex-c34)
+		basic_machine=c34-convex
+		os=-bsd
+		;;
+	convex-c38)
+		basic_machine=c38-convex
+		os=-bsd
+		;;
+	cray | j90)
+		basic_machine=j90-cray
+		os=-unicos
+		;;
+	craynv)
+		basic_machine=craynv-cray
+		os=-unicosmp
+		;;
+	cr16 | cr16-*)
+		basic_machine=cr16-unknown
+		os=-elf
+		;;
+	crds | unos)
+		basic_machine=m68k-crds
+		;;
+	crisv32 | crisv32-* | etraxfs*)
+		basic_machine=crisv32-axis
+		;;
+	cris | cris-* | etrax*)
+		basic_machine=cris-axis
+		;;
+	crx)
+		basic_machine=crx-unknown
+		os=-elf
+		;;
+	da30 | da30-*)
+		basic_machine=m68k-da30
+		;;
+	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
+		basic_machine=mips-dec
 		;;
 	decsystem10* | dec10*)
-		cpu=pdp10
-		vendor=dec
-		basic_os=tops10
+		basic_machine=pdp10-dec
+		os=-tops10
 		;;
 	decsystem20* | dec20*)
-		cpu=pdp10
-		vendor=dec
-		basic_os=tops20
+		basic_machine=pdp10-dec
+		os=-tops20
 		;;
 	delta | 3300 | motorola-3300 | motorola-delta \
 	      | 3300-motorola | delta-motorola)
-		cpu=m68k
-		vendor=motorola
+		basic_machine=m68k-motorola
+		;;
+	delta88)
+		basic_machine=m88k-motorola
+		os=-sysv3
+		;;
+	dicos)
+		basic_machine=i686-pc
+		os=-dicos
+		;;
+	djgpp)
+		basic_machine=i586-pc
+		os=-msdosdjgpp
+		;;
+	dpx20 | dpx20-*)
+		basic_machine=rs6000-bull
+		os=-bosx
 		;;
 	dpx2*)
-		cpu=m68k
-		vendor=bull
-		basic_os=sysv3
+		basic_machine=m68k-bull
+		os=-sysv3
 		;;
-	encore | umax | mmax)
-		cpu=ns32k
-		vendor=encore
+	e500v[12])
+		basic_machine=powerpc-unknown
+		os=$os"spe"
+		;;
+	e500v[12]-*)
+		basic_machine=powerpc-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		os=$os"spe"
+		;;
+	ebmon29k)
+		basic_machine=a29k-amd
+		os=-ebmon
 		;;
 	elxsi)
-		cpu=elxsi
-		vendor=elxsi
-		basic_os=${basic_os:-bsd}
+		basic_machine=elxsi-elxsi
+		os=-bsd
+		;;
+	encore | umax | mmax)
+		basic_machine=ns32k-encore
+		;;
+	es1800 | OSE68k | ose68k | ose | OSE)
+		basic_machine=m68k-ericsson
+		os=-ose
 		;;
 	fx2800)
-		cpu=i860
-		vendor=alliant
+		basic_machine=i860-alliant
 		;;
 	genix)
-		cpu=ns32k
-		vendor=ns
+		basic_machine=ns32k-ns
+		;;
+	gmicro)
+		basic_machine=tron-gmicro
+		os=-sysv
+		;;
+	go32)
+		basic_machine=i386-pc
+		os=-go32
 		;;
 	h3050r* | hiux*)
-		cpu=hppa1.1
-		vendor=hitachi
-		basic_os=hiuxwe2
+		basic_machine=hppa1.1-hitachi
+		os=-hiuxwe2
+		;;
+	h8300hms)
+		basic_machine=h8300-hitachi
+		os=-hms
+		;;
+	h8300xray)
+		basic_machine=h8300-hitachi
+		os=-xray
+		;;
+	h8500hms)
+		basic_machine=h8500-hitachi
+		os=-hms
+		;;
+	harris)
+		basic_machine=m88k-harris
+		os=-sysv3
+		;;
+	hp300-*)
+		basic_machine=m68k-hp
+		;;
+	hp300bsd)
+		basic_machine=m68k-hp
+		os=-bsd
+		;;
+	hp300hpux)
+		basic_machine=m68k-hp
+		os=-hpux
 		;;
 	hp3k9[0-9][0-9] | hp9[0-9][0-9])
-		cpu=hppa1.0
-		vendor=hp
+		basic_machine=hppa1.0-hp
 		;;
 	hp9k2[0-9][0-9] | hp9k31[0-9])
-		cpu=m68000
-		vendor=hp
+		basic_machine=m68000-hp
 		;;
 	hp9k3[2-9][0-9])
-		cpu=m68k
-		vendor=hp
+		basic_machine=m68k-hp
 		;;
 	hp9k6[0-9][0-9] | hp6[0-9][0-9])
-		cpu=hppa1.0
-		vendor=hp
+		basic_machine=hppa1.0-hp
 		;;
 	hp9k7[0-79][0-9] | hp7[0-79][0-9])
-		cpu=hppa1.1
-		vendor=hp
+		basic_machine=hppa1.1-hp
 		;;
 	hp9k78[0-9] | hp78[0-9])
 		# FIXME: really hppa2.0-hp
-		cpu=hppa1.1
-		vendor=hp
+		basic_machine=hppa1.1-hp
 		;;
 	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
 		# FIXME: really hppa2.0-hp
-		cpu=hppa1.1
-		vendor=hp
+		basic_machine=hppa1.1-hp
 		;;
 	hp9k8[0-9][13679] | hp8[0-9][13679])
-		cpu=hppa1.1
-		vendor=hp
+		basic_machine=hppa1.1-hp
 		;;
 	hp9k8[0-9][0-9] | hp8[0-9][0-9])
-		cpu=hppa1.0
-		vendor=hp
+		basic_machine=hppa1.0-hp
+		;;
+	hppaosf)
+		basic_machine=hppa1.1-hp
+		os=-osf
+		;;
+	hppro)
+		basic_machine=hppa1.1-hp
+		os=-proelf
+		;;
+	i370-ibm* | ibm*)
+		basic_machine=i370-ibm
 		;;
 	i*86v32)
-		cpu=`echo "$1" | sed -e 's/86.*/86/'`
-		vendor=pc
-		basic_os=sysv32
+		basic_machine=`echo "$1" | sed -e 's/86.*/86-pc/'`
+		os=-sysv32
 		;;
 	i*86v4*)
-		cpu=`echo "$1" | sed -e 's/86.*/86/'`
-		vendor=pc
-		basic_os=sysv4
+		basic_machine=`echo "$1" | sed -e 's/86.*/86-pc/'`
+		os=-sysv4
 		;;
 	i*86v)
-		cpu=`echo "$1" | sed -e 's/86.*/86/'`
-		vendor=pc
-		basic_os=sysv
+		basic_machine=`echo "$1" | sed -e 's/86.*/86-pc/'`
+		os=-sysv
 		;;
 	i*86sol2)
-		cpu=`echo "$1" | sed -e 's/86.*/86/'`
-		vendor=pc
-		basic_os=solaris2
+		basic_machine=`echo "$1" | sed -e 's/86.*/86-pc/'`
+		os=-solaris2
+		;;
+	i386mach)
+		basic_machine=i386-mach
+		os=-mach
 		;;
-	j90 | j90-cray)
-		cpu=j90
-		vendor=cray
-		basic_os=${basic_os:-unicos}
+	vsta)
+		basic_machine=i386-unknown
+		os=-vsta
 		;;
 	iris | iris4d)
-		cpu=mips
-		vendor=sgi
-		case $basic_os in
-		    irix*)
+		basic_machine=mips-sgi
+		case $os in
+		    -irix*)
 			;;
 		    *)
-			basic_os=irix4
+			os=-irix4
 			;;
 		esac
 		;;
+	isi68 | isi)
+		basic_machine=m68k-isi
+		os=-sysv
+		;;
+	leon-*|leon[3-9]-*)
+		basic_machine=sparc-`echo "$basic_machine" | sed 's/-.*//'`
+		;;
+	m68knommu)
+		basic_machine=m68k-unknown
+		os=-linux
+		;;
+	m68knommu-*)
+		basic_machine=m68k-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
+	magnum | m3230)
+		basic_machine=mips-mips
+		os=-sysv
+		;;
+	merlin)
+		basic_machine=ns32k-utek
+		os=-sysv
+		;;
+	microblaze*)
+		basic_machine=microblaze-xilinx
+		;;
+	mingw64)
+		basic_machine=x86_64-pc
+		os=-mingw64
+		;;
+	mingw32)
+		basic_machine=i686-pc
+		os=-mingw32
+		;;
+	mingw32ce)
+		basic_machine=arm-unknown
+		os=-mingw32ce
+		;;
 	miniframe)
-		cpu=m68000
-		vendor=convergent
+		basic_machine=m68000-convergent
+		;;
+	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
+		basic_machine=m68k-atari
+		os=-mint
+		;;
+	mips3*-*)
+		basic_machine=`echo "$basic_machine" | sed -e 's/mips3/mips64/'`
+		;;
+	mips3*)
+		basic_machine=`echo "$basic_machine" | sed -e 's/mips3/mips64/'`-unknown
+		;;
+	monitor)
+		basic_machine=m68k-rom68k
+		os=-coff
+		;;
+	morphos)
+		basic_machine=powerpc-unknown
+		os=-morphos
+		;;
+	moxiebox)
+		basic_machine=moxie-unknown
+		os=-moxiebox
 		;;
-	*mint | mint[0-9]* | *MiNT | *MiNT[0-9]*)
-		cpu=m68k
-		vendor=atari
-		basic_os=mint
+	msdos)
+		basic_machine=i386-pc
+		os=-msdos
+		;;
+	ms1-*)
+		basic_machine=`echo "$basic_machine" | sed -e 's/ms1-/mt-/'`
+		;;
+	msys)
+		basic_machine=i686-pc
+		os=-msys
+		;;
+	mvs)
+		basic_machine=i370-ibm
+		os=-mvs
+		;;
+	nacl)
+		basic_machine=le32-unknown
+		os=-nacl
+		;;
+	ncr3000)
+		basic_machine=i486-ncr
+		os=-sysv4
+		;;
+	netbsd386)
+		basic_machine=i386-unknown
+		os=-netbsd
+		;;
+	netwinder)
+		basic_machine=armv4l-rebel
+		os=-linux
+		;;
+	news | news700 | news800 | news900)
+		basic_machine=m68k-sony
+		os=-newsos
+		;;
+	news1000)
+		basic_machine=m68030-sony
+		os=-newsos
 		;;
 	news-3600 | risc-news)
-		cpu=mips
-		vendor=sony
-		basic_os=newsos
+		basic_machine=mips-sony
+		os=-newsos
+		;;
+	necv70)
+		basic_machine=v70-nec
+		os=-sysv
 		;;
 	next | m*-next)
-		cpu=m68k
-		vendor=next
-		case $basic_os in
-		    openstep*)
-		        ;;
-		    nextstep*)
+		basic_machine=m68k-next
+		case $os in
+		    -nextstep* )
 			;;
-		    ns2*)
-		      basic_os=nextstep2
+		    -ns2*)
+		      os=-nextstep2
 			;;
 		    *)
-		      basic_os=nextstep3
+		      os=-nextstep3
 			;;
 		esac
 		;;
+	nh3000)
+		basic_machine=m68k-harris
+		os=-cxux
+		;;
+	nh[45]000)
+		basic_machine=m88k-harris
+		os=-cxux
+		;;
+	nindy960)
+		basic_machine=i960-intel
+		os=-nindy
+		;;
+	mon960)
+		basic_machine=i960-intel
+		os=-mon960
+		;;
+	nonstopux)
+		basic_machine=mips-compaq
+		os=-nonstopux
+		;;
 	np1)
-		cpu=np1
-		vendor=gould
+		basic_machine=np1-gould
+		;;
+	neo-tandem)
+		basic_machine=neo-tandem
+		;;
+	nse-tandem)
+		basic_machine=nse-tandem
+		;;
+	nsr-tandem)
+		basic_machine=nsr-tandem
+		;;
+	nsv-tandem)
+		basic_machine=nsv-tandem
+		;;
+	nsx-tandem)
+		basic_machine=nsx-tandem
 		;;
 	op50n-* | op60c-*)
-		cpu=hppa1.1
-		vendor=oki
-		basic_os=proelf
+		basic_machine=hppa1.1-oki
+		os=-proelf
+		;;
+	openrisc | openrisc-*)
+		basic_machine=or32-unknown
+		;;
+	os400)
+		basic_machine=powerpc-ibm
+		os=-os400
+		;;
+	OSE68000 | ose68000)
+		basic_machine=m68000-ericsson
+		os=-ose
+		;;
+	os68k)
+		basic_machine=m68k-none
+		os=-os68k
 		;;
 	pa-hitachi)
-		cpu=hppa1.1
-		vendor=hitachi
-		basic_os=hiuxwe2
+		basic_machine=hppa1.1-hitachi
+		os=-hiuxwe2
+		;;
+	paragon)
+		basic_machine=i860-intel
+		os=-osf
+		;;
+	parisc)
+		basic_machine=hppa-unknown
+		os=-linux
+		;;
+	parisc-*)
+		basic_machine=hppa-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		os=-linux
 		;;
 	pbd)
-		cpu=sparc
-		vendor=tti
+		basic_machine=sparc-tti
 		;;
 	pbb)
-		cpu=m68k
-		vendor=tti
+		basic_machine=m68k-tti
+		;;
+	pc532 | pc532-*)
+		basic_machine=ns32k-pc532
+		;;
+	pc98)
+		basic_machine=i386-pc
 		;;
-	pc532)
-		cpu=ns32k
-		vendor=pc532
+	pc98-*)
+		basic_machine=i386-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		;;
+	pentium | p5 | k5 | k6 | nexgen | viac3)
+		basic_machine=i586-pc
+		;;
+	pentiumpro | p6 | 6x86 | athlon | athlon_*)
+		basic_machine=i686-pc
+		;;
+	pentiumii | pentium2 | pentiumiii | pentium3)
+		basic_machine=i686-pc
+		;;
+	pentium4)
+		basic_machine=i786-pc
+		;;
+	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
+		basic_machine=i586-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		;;
+	pentiumpro-* | p6-* | 6x86-* | athlon-*)
+		basic_machine=i686-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		;;
+	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
+		basic_machine=i686-`echo "$basic_machine" | sed 's/^[^-]*-//'`
+		;;
+	pentium4-*)
+		basic_machine=i786-`echo "$basic_machine" | sed 's/^[^-]*-//'`
 		;;
 	pn)
-		cpu=pn
-		vendor=gould
+		basic_machine=pn-gould
 		;;
-	power)
-		cpu=power
-		vendor=ibm
+	power)	basic_machine=power-ibm
 		;;
-	ps2)
-		cpu=i386
-		vendor=ibm
+	ppc | ppcbe)	basic_machine=powerpc-unknown
 		;;
-	rm[46]00)
-		cpu=mips
-		vendor=siemens
+	ppc-* | ppcbe-*)
+		basic_machine=powerpc-`echo "$basic_machine" | sed 's/^[^-]*-//'`
 		;;
-	rtpc | rtpc-*)
-		cpu=romp
-		vendor=ibm
+	ppcle | powerpclittle)
+		basic_machine=powerpcle-unknown
 		;;
-	sde)
-		cpu=mipsisa32
-		vendor=sde
-		basic_os=${basic_os:-elf}
+	ppcle-* | powerpclittle-*)
+		basic_machine=powerpcle-`echo "$basic_machine" | sed 's/^[^-]*-//'`
 		;;
-	simso-wrs)
-		cpu=sparclite
-		vendor=wrs
-		basic_os=vxworks
+	ppc64)	basic_machine=powerpc64-unknown
 		;;
-	tower | tower-32)
-		cpu=m68k
-		vendor=ncr
+	ppc64-*) basic_machine=powerpc64-`echo "$basic_machine" | sed 's/^[^-]*-//'`
 		;;
-	vpp*|vx|vx-*)
-		cpu=f301
-		vendor=fujitsu
+	ppc64le | powerpc64little)
+		basic_machine=powerpc64le-unknown
 		;;
-	w65)
-		cpu=w65
-		vendor=wdc
+	ppc64le-* | powerpc64little-*)
+		basic_machine=powerpc64le-`echo "$basic_machine" | sed 's/^[^-]*-//'`
 		;;
-	w89k-*)
-		cpu=hppa1.1
-		vendor=winbond
-		basic_os=proelf
+	ps2)
+		basic_machine=i386-ibm
 		;;
-	none)
-		cpu=none
-		vendor=none
+	pw32)
+		basic_machine=i586-unknown
+		os=-pw32
 		;;
-	leon|leon[3-9])
-		cpu=sparc
-		vendor=$basic_machine
+	rdos | rdos64)
+		basic_machine=x86_64-pc
+		os=-rdos
 		;;
-	leon-*|leon[3-9]-*)
-		cpu=sparc
-		vendor=`echo "$basic_machine" | sed 's/-.*//'`
+	rdos32)
+		basic_machine=i386-pc
+		os=-rdos
 		;;
-
-	*-*)
-		# shellcheck disable=SC2162
-		IFS="-" read cpu vendor <<EOF
-$basic_machine
-EOF
+	rom68k)
+		basic_machine=m68k-rom68k
+		os=-coff
 		;;
-	# We use `pc' rather than `unknown'
-	# because (1) that's what they normally are, and
-	# (2) the word "unknown" tends to confuse beginning users.
-	i*86 | x86_64)
-		cpu=$basic_machine
-		vendor=pc
+	rm[46]00)
+		basic_machine=mips-siemens
 		;;
-	# These rules are duplicated from below for sake of the special case above;
-	# i.e. things that normalized to x86 arches should also default to "pc"
-	pc98)
-		cpu=i386
-		vendor=pc
+	rtpc | rtpc-*)
+		basic_machine=romp-ibm
 		;;
-	x64 | amd64)
-		cpu=x86_64
-		vendor=pc
+	s390 | s390-*)
+		basic_machine=s390-ibm
 		;;
-	# Recognize the basic CPU types without company name.
-	*)
-		cpu=$basic_machine
-		vendor=unknown
+	s390x | s390x-*)
+		basic_machine=s390x-ibm
 		;;
-esac
-
-unset -v basic_machine
-
-# Decode basic machines in the full and proper CPU-Company form.
-case $cpu-$vendor in
-	# Here we handle the default manufacturer of certain CPU types in canonical form. It is in
-	# some cases the only manufacturer, in others, it is the most popular.
-	craynv-unknown)
-		vendor=cray
-		basic_os=${basic_os:-unicosmp}
+	sa29200)
+		basic_machine=a29k-amd
+		os=-udi
 		;;
-	c90-unknown | c90-cray)
-		vendor=cray
-		basic_os=${Basic_os:-unicos}
+	sb1)
+		basic_machine=mipsisa64sb1-unknown
 		;;
-	fx80-unknown)
-		vendor=alliant
+	sb1el)
+		basic_machine=mipsisa64sb1el-unknown
 		;;
-	romp-unknown)
-		vendor=ibm
+	sde)
+		basic_machine=mipsisa32-sde
+		os=-elf
 		;;
-	mmix-unknown)
-		vendor=knuth
+	sei)
+		basic_machine=mips-sei
+		os=-seiux
 		;;
-	microblaze-unknown | microblazeel-unknown)
-		vendor=xilinx
+	sequent)
+		basic_machine=i386-sequent
 		;;
-	rs6000-unknown)
-		vendor=ibm
+	sh5el)
+		basic_machine=sh5le-unknown
 		;;
-	vax-unknown)
-		vendor=dec
+	simso-wrs)
+		basic_machine=sparclite-wrs
+		os=-vxworks
 		;;
-	pdp11-unknown)
-		vendor=dec
+	sps7)
+		basic_machine=m68k-bull
+		os=-sysv2
 		;;
-	we32k-unknown)
-		vendor=att
+	spur)
+		basic_machine=spur-unknown
 		;;
-	cydra-unknown)
-		vendor=cydrome
+	st2000)
+		basic_machine=m68k-tandem
 		;;
-	i370-ibm*)
-		vendor=ibm
+	stratus)
+		basic_machine=i860-stratus
+		os=-sysv4
 		;;
-	orion-unknown)
-		vendor=highlevel
+	strongarm-* | thumb-*)
+		basic_machine=arm-`echo "$basic_machine" | sed 's/^[^-]*-//'`
 		;;
-	xps-unknown | xps100-unknown)
-		cpu=xps100
-		vendor=honeywell
+	sun2)
+		basic_machine=m68000-sun
 		;;
-
-	# Here we normalize CPU types with a missing or matching vendor
-	dpx20-unknown | dpx20-bull)
-		cpu=rs6000
-		vendor=bull
-		basic_os=${basic_os:-bosx}
+	sun2os3)
+		basic_machine=m68000-sun
+		os=-sunos3
 		;;
-
-	# Here we normalize CPU types irrespective of the vendor
-	amd64-*)
-		cpu=x86_64
+	sun2os4)
+		basic_machine=m68000-sun
+		os=-sunos4
 		;;
-	blackfin-*)
-		cpu=bfin
-		basic_os=linux
+	sun3os3)
+		basic_machine=m68k-sun
+		os=-sunos3
 		;;
-	c54x-*)
-		cpu=tic54x
+	sun3os4)
+		basic_machine=m68k-sun
+		os=-sunos4
 		;;
-	c55x-*)
-		cpu=tic55x
+	sun4os3)
+		basic_machine=sparc-sun
+		os=-sunos3
 		;;
-	c6x-*)
-		cpu=tic6x
+	sun4os4)
+		basic_machine=sparc-sun
+		os=-sunos4
 		;;
-	e500v[12]-*)
-		cpu=powerpc
-		basic_os=${basic_os}"spe"
+	sun4sol2)
+		basic_machine=sparc-sun
+		os=-solaris2
 		;;
-	mips3*-*)
-		cpu=mips64
+	sun3 | sun3-*)
+		basic_machine=m68k-sun
 		;;
-	ms1-*)
-		cpu=mt
+	sun4)
+		basic_machine=sparc-sun
 		;;
-	m68knommu-*)
-		cpu=m68k
-		basic_os=linux
+	sun386 | sun386i | roadrunner)
+		basic_machine=i386-sun
 		;;
-	m9s12z-* | m68hcs12z-* | hcs12z-* | s12z-*)
-		cpu=s12z
+	sv1)
+		basic_machine=sv1-cray
+		os=-unicos
 		;;
-	openrisc-*)
-		cpu=or32
+	symmetry)
+		basic_machine=i386-sequent
+		os=-dynix
 		;;
-	parisc-*)
-		cpu=hppa
-		basic_os=linux
+	t3e)
+		basic_machine=alphaev5-cray
+		os=-unicos
 		;;
-	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
-		cpu=i586
+	t90)
+		basic_machine=t90-cray
+		os=-unicos
 		;;
-	pentiumpro-* | p6-* | 6x86-* | athlon-* | athalon_*-*)
-		cpu=i686
+	tile*)
+		basic_machine=$basic_machine-unknown
+		os=-linux-gnu
 		;;
-	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
-		cpu=i686
+	tx39)
+		basic_machine=mipstx39-unknown
 		;;
-	pentium4-*)
-		cpu=i786
+	tx39el)
+		basic_machine=mipstx39el-unknown
 		;;
-	pc98-*)
-		cpu=i386
+	toad1)
+		basic_machine=pdp10-xkl
+		os=-tops20
 		;;
-	ppc-* | ppcbe-*)
-		cpu=powerpc
+	tower | tower-32)
+		basic_machine=m68k-ncr
 		;;
-	ppcle-* | powerpclittle-*)
-		cpu=powerpcle
+	tpf)
+		basic_machine=s390x-ibm
+		os=-tpf
 		;;
-	ppc64-*)
-		cpu=powerpc64
+	udi29k)
+		basic_machine=a29k-amd
+		os=-udi
 		;;
-	ppc64le-* | powerpc64little-*)
-		cpu=powerpc64le
+	ultra3)
+		basic_machine=a29k-nyu
+		os=-sym1
 		;;
-	sb1-*)
-		cpu=mipsisa64sb1
+	v810 | necv810)
+		basic_machine=v810-nec
+		os=-none
 		;;
-	sb1el-*)
-		cpu=mipsisa64sb1el
+	vaxv)
+		basic_machine=vax-dec
+		os=-sysv
 		;;
-	sh5e[lb]-*)
-		cpu=`echo "$cpu" | sed 's/^\(sh.\)e\(.\)$/\1\2e/'`
+	vms)
+		basic_machine=vax-dec
+		os=-vms
 		;;
-	spur-*)
-		cpu=spur
+	vpp*|vx|vx-*)
+		basic_machine=f301-fujitsu
 		;;
-	strongarm-* | thumb-*)
-		cpu=arm
+	vxworks960)
+		basic_machine=i960-wrs
+		os=-vxworks
+		;;
+	vxworks68)
+		basic_machine=m68k-wrs
+		os=-vxworks
 		;;
-	tx39-*)
-		cpu=mipstx39
+	vxworks29k)
+		basic_machine=a29k-wrs
+		os=-vxworks
 		;;
-	tx39el-*)
-		cpu=mipstx39el
+	w65*)
+		basic_machine=w65-wdc
+		os=-none
+		;;
+	w89k-*)
+		basic_machine=hppa1.1-winbond
+		os=-proelf
 		;;
-	x64-*)
-		cpu=x86_64
+	x64)
+		basic_machine=x86_64-pc
+		;;
+	xbox)
+		basic_machine=i686-pc
+		os=-mingw32
+		;;
+	xps | xps100)
+		basic_machine=xps100-honeywell
 		;;
 	xscale-* | xscalee[bl]-*)
-		cpu=`echo "$cpu" | sed 's/^xscale/arm/'`
+		basic_machine=`echo "$basic_machine" | sed 's/^xscale/arm/'`
+		;;
+	ymp)
+		basic_machine=ymp-cray
+		os=-unicos
 		;;
-	arm64-*)
-		cpu=aarch64
+	none)
+		basic_machine=none-none
+		os=-none
 		;;
 
-	# Recognize the canonical CPU Types that limit and/or modify the
-	# company names they are paired with.
-	cr16-*)
-		basic_os=${basic_os:-elf}
+# Here we handle the default manufacturer of certain CPU types.  It is in
+# some cases the only manufacturer, in others, it is the most popular.
+	w89k)
+		basic_machine=hppa1.1-winbond
 		;;
-	crisv32-* | etraxfs*-*)
-		cpu=crisv32
-		vendor=axis
+	op50n)
+		basic_machine=hppa1.1-oki
 		;;
-	cris-* | etrax*-*)
-		cpu=cris
-		vendor=axis
+	op60c)
+		basic_machine=hppa1.1-oki
 		;;
-	crx-*)
-		basic_os=${basic_os:-elf}
+	romp)
+		basic_machine=romp-ibm
 		;;
-	neo-tandem)
-		cpu=neo
-		vendor=tandem
+	mmix)
+		basic_machine=mmix-knuth
 		;;
-	nse-tandem)
-		cpu=nse
-		vendor=tandem
+	rs6000)
+		basic_machine=rs6000-ibm
 		;;
-	nsr-tandem)
-		cpu=nsr
-		vendor=tandem
+	vax)
+		basic_machine=vax-dec
 		;;
-	nsv-tandem)
-		cpu=nsv
-		vendor=tandem
+	pdp11)
+		basic_machine=pdp11-dec
 		;;
-	nsx-tandem)
-		cpu=nsx
-		vendor=tandem
+	we32k)
+		basic_machine=we32k-att
 		;;
-	mipsallegrexel-sony)
-		cpu=mipsallegrexel
-		vendor=sony
+	sh[1234] | sh[24]a | sh[24]aeb | sh[34]eb | sh[1234]le | sh[23]ele)
+		basic_machine=sh-unknown
 		;;
-	tile*-*)
-		basic_os=${basic_os:-linux-gnu}
+	cydra)
+		basic_machine=cydra-cydrome
+		;;
+	orion)
+		basic_machine=orion-highlevel
+		;;
+	orion105)
+		basic_machine=clipper-highlevel
+		;;
+	mac | mpw | mac-mpw)
+		basic_machine=m68k-apple
+		;;
+	pmac | pmac-mpw)
+		basic_machine=powerpc-apple
+		;;
+	*-unknown)
+		# Make sure to match an already-canonicalized machine name.
 		;;
-
 	*)
-		# Recognize the canonical CPU types that are allowed with any
-		# company name.
-		case $cpu in
-			1750a | 580 \
-			| a29k \
-			| aarch64 | aarch64_be \
-			| abacus \
-			| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] \
-			| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] \
-			| alphapca5[67] | alpha64pca5[67] \
-			| am33_2.0 \
-			| amdgcn \
-			| arc | arceb \
-			| arm | arm[lb]e | arme[lb] | armv* \
-			| avr | avr32 \
-			| asmjs \
-			| ba \
-			| be32 | be64 \
-			| bfin | bpf | bs2000 \
-			| c[123]* | c30 | [cjt]90 | c4x \
-			| c8051 | clipper | craynv | csky | cydra \
-			| d10v | d30v | dlx | dsp16xx \
-			| e2k | elxsi | epiphany \
-			| f30[01] | f700 | fido | fr30 | frv | ft32 | fx80 \
-			| h8300 | h8500 \
-			| hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
-			| hexagon \
-			| i370 | i*86 | i860 | i960 | ia16 | ia64 \
-			| ip2k | iq2000 \
-			| k1om \
-			| le32 | le64 \
-			| lm32 \
-			| m32c | m32r | m32rle \
-			| m5200 | m68000 | m680[012346]0 | m68360 | m683?2 | m68k \
-			| m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x \
-			| m88110 | m88k | maxq | mb | mcore | mep | metag \
-			| microblaze | microblazeel \
-			| mips | mipsbe | mipseb | mipsel | mipsle \
-			| mips16 \
-			| mips64 | mips64eb | mips64el \
-			| mips64octeon | mips64octeonel \
-			| mips64orion | mips64orionel \
-			| mips64r5900 | mips64r5900el \
-			| mips64vr | mips64vrel \
-			| mips64vr4100 | mips64vr4100el \
-			| mips64vr4300 | mips64vr4300el \
-			| mips64vr5000 | mips64vr5000el \
-			| mips64vr5900 | mips64vr5900el \
-			| mipsisa32 | mipsisa32el \
-			| mipsisa32r2 | mipsisa32r2el \
-			| mipsisa32r6 | mipsisa32r6el \
-			| mipsisa64 | mipsisa64el \
-			| mipsisa64r2 | mipsisa64r2el \
-			| mipsisa64r6 | mipsisa64r6el \
-			| mipsisa64sb1 | mipsisa64sb1el \
-			| mipsisa64sr71k | mipsisa64sr71kel \
-			| mipsr5900 | mipsr5900el \
-			| mipstx39 | mipstx39el \
-			| mmix \
-			| mn10200 | mn10300 \
-			| moxie \
-			| mt \
-			| msp430 \
-			| nds32 | nds32le | nds32be \
-			| nfp \
-			| nios | nios2 | nios2eb | nios2el \
-			| none | np1 | ns16k | ns32k | nvptx \
-			| open8 \
-			| or1k* \
-			| or32 \
-			| orion \
-			| picochip \
-			| pdp10 | pdp11 | pj | pjl | pn | power \
-			| powerpc | powerpc64 | powerpc64le | powerpcle | powerpcspe \
-			| pru \
-			| pyramid \
-			| riscv | riscv32 | riscv64 \
-			| rl78 | romp | rs6000 | rx \
-			| s390 | s390x \
-			| score \
-			| sh | shl \
-			| sh[1234] | sh[24]a | sh[24]ae[lb] | sh[23]e | she[lb] | sh[lb]e \
-			| sh[1234]e[lb] |  sh[12345][lb]e | sh[23]ele | sh64 | sh64le \
-			| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet \
-			| sparclite \
-			| sparcv8 | sparcv9 | sparcv9b | sparcv9v | sv1 | sx* \
-			| spu \
-			| tahoe \
-			| tic30 | tic4x | tic54x | tic55x | tic6x | tic80 \
-			| tron \
-			| ubicom32 \
-			| v70 | v850 | v850e | v850e1 | v850es | v850e2 | v850e2v3 \
-			| vax \
-			| visium \
-			| w65 \
-			| wasm32 | wasm64 \
-			| we32k \
-			| x86 | x86_64 | xc16x | xgate | xps100 \
-			| xstormy16 | xtensa* \
-			| ymp \
-			| z8k | z80)
-				;;
-
-			*)
-				echo Invalid configuration \`"$1"\': machine \`"$cpu-$vendor"\' not recognized 1>&2
-				exit 1
-				;;
-		esac
+		echo Invalid configuration \`"$1"\': machine \`"$basic_machine"\' not recognized 1>&2
+		exit 1
 		;;
 esac
 
 # Here we canonicalize certain aliases for manufacturers.
-case $vendor in
-	digital*)
-		vendor=dec
+case $basic_machine in
+	*-digital*)
+		basic_machine=`echo "$basic_machine" | sed 's/digital.*/dec/'`
 		;;
-	commodore*)
-		vendor=cbm
+	*-commodore*)
+		basic_machine=`echo "$basic_machine" | sed 's/commodore.*/cbm/'`
 		;;
 	*)
 		;;
@@ -1278,215 +1336,203 @@ esac
 
 # Decode manufacturer-specific aliases for certain operating systems.
 
-if [ x$basic_os != x ]
+if [ x"$os" != x"" ]
 then
-
-# First recognize some ad-hoc caes, or perhaps split kernel-os, or else just
-# set os.
-case $basic_os in
-	gnu/linux*)
-		kernel=linux
-		os=`echo $basic_os | sed -e 's|gnu/linux|gnu|'`
-		;;
-	nto-qnx*)
-		kernel=nto
-		os=`echo $basic_os | sed -e 's|nto-qnx|qnx|'`
-		;;
-	*-*)
-		# shellcheck disable=SC2162
-		IFS="-" read kernel os <<EOF
-$basic_os
-EOF
-		;;
-	# Default OS when just kernel was specified
-	nto*)
-		kernel=nto
-		os=`echo $basic_os | sed -e 's|nto|qnx|'`
-		;;
-	linux*)
-		kernel=linux
-		os=`echo $basic_os | sed -e 's|linux|gnu|'`
-		;;
-	*)
-		kernel=
-		os=$basic_os
-		;;
-esac
-
-# Now, normalize the OS (knowing we just have one component, it's not a kernel,
-# etc.)
 case $os in
 	# First match some system type aliases that might get confused
 	# with valid system types.
-	# solaris* is a basic system type, with this one exception.
-	auroraux)
-		os=auroraux
-		;;
-	bluegene*)
-		os=cnk
+	# -solaris* is a basic system type, with this one exception.
+	-auroraux)
+		os=-auroraux
 		;;
-	solaris1 | solaris1.*)
+	-solaris1 | -solaris1.*)
 		os=`echo $os | sed -e 's|solaris1|sunos4|'`
 		;;
-	solaris)
-		os=solaris2
-		;;
-	unixware*)
-		os=sysv4.2uw
-		;;
-	# es1800 is here to avoid being matched by es* (a different OS)
-	es1800*)
-		os=ose
-		;;
-	# Some version numbers need modification
-	chorusos*)
-		os=chorusos
-		;;
-	isc)
-		os=isc2.2
-		;;
-	sco6)
-		os=sco5v6
-		;;
-	sco5)
-		os=sco3.2v5
+	-solaris)
+		os=-solaris2
 		;;
-	sco4)
-		os=sco3.2v4
+	-unixware*)
+		os=-sysv4.2uw
 		;;
-	sco3.2.[4-9]*)
-		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
-		;;
-	sco*v* | scout)
-		# Don't match below
+	-gnu/linux*)
+		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
 		;;
-	sco*)
-		os=sco3.2v2
-		;;
-	psos*)
-		os=psos
+	# es1800 is here to avoid being matched by es* (a different OS)
+	-es1800*)
+		os=-ose
 		;;
-	qnx*)
-		case $cpu in
-		    x86 | i*86)
+	# Now accept the basic system types.
+	# The portable systems comes first.
+	# Each alternative MUST end in a * to match a version number.
+	# -sysv* is not here because it comes later, after sysvr4.
+	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
+	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -cnk* | -sunos | -sunos[34]*\
+	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -auroraux* | -solaris* \
+	      | -sym* | -kopensolaris* | -plan9* \
+	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
+	      | -aos* | -aros* | -cloudabi* | -sortix* \
+	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
+	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
+	      | -hiux* | -knetbsd* | -mirbsd* | -netbsd* \
+	      | -bitrig* | -openbsd* | -solidbsd* | -libertybsd* \
+	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
+	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
+	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
+	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
+	      | -chorusos* | -chorusrdb* | -cegcc* | -glidix* \
+	      | -cygwin* | -msys* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
+	      | -midipix* | -mingw32* | -mingw64* | -linux-gnu* | -linux-android* \
+	      | -linux-newlib* | -linux-musl* | -linux-uclibc* \
+	      | -uxpv* | -beos* | -mpeix* | -udk* | -moxiebox* \
+	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* \
+	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
+	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
+	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
+	      | -morphos* | -superux* | -rtmk* | -windiss* \
+	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
+	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es* \
+	      | -onefs* | -tirtos* | -phoenix* | -fuchsia* | -redox* | -bme* \
+	      | -midnightbsd*)
+	# Remember, each alternative MUST END IN *, to match a version number.
+		;;
+	-qnx*)
+		case $basic_machine in
+		    x86-* | i*86-*)
 			;;
 		    *)
-			os=nto-$os
+			os=-nto$os
 			;;
 		esac
 		;;
-	hiux*)
-		os=hiuxwe2
-		;;
-	lynx*178)
-		os=lynxos178
+	-nto-qnx*)
 		;;
-	lynx*5)
-		os=lynxos5
+	-nto*)
+		os=`echo $os | sed -e 's|nto|nto-qnx|'`
 		;;
-	lynxos*)
-		# don't get caught up in next wildcard
+	-sim | -xray | -os68k* | -v88r* \
+	      | -windows* | -osx | -abug | -netware* | -os9* \
+	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
 		;;
-	lynx*)
-		os=lynxos
-		;;
-	mac[0-9]*)
+	-mac*)
 		os=`echo "$os" | sed -e 's|mac|macos|'`
 		;;
-	opened*)
-		os=openedition
+	-linux-dietlibc)
+		os=-linux-dietlibc
 		;;
-	os400*)
-		os=os400
+	-linux*)
+		os=`echo $os | sed -e 's|linux|linux-gnu|'`
 		;;
-	sunos5*)
+	-sunos5*)
 		os=`echo "$os" | sed -e 's|sunos5|solaris2|'`
 		;;
-	sunos6*)
+	-sunos6*)
 		os=`echo "$os" | sed -e 's|sunos6|solaris3|'`
 		;;
-	wince*)
-		os=wince
+	-opened*)
+		os=-openedition
 		;;
-	utek*)
-		os=bsd
+	-os400*)
+		os=-os400
 		;;
-	dynix*)
-		os=bsd
+	-wince*)
+		os=-wince
 		;;
-	acis*)
-		os=aos
+	-utek*)
+		os=-bsd
 		;;
-	atheos*)
-		os=atheos
+	-dynix*)
+		os=-bsd
 		;;
-	syllable*)
-		os=syllable
+	-acis*)
+		os=-aos
 		;;
-	386bsd)
-		os=bsd
+	-atheos*)
+		os=-atheos
+		;;
+	-syllable*)
+		os=-syllable
 		;;
-	ctix* | uts*)
-		os=sysv
+	-386bsd)
+		os=-bsd
 		;;
-	nova*)
-		os=rtmk-nova
+	-ctix* | -uts*)
+		os=-sysv
 		;;
-	ns2)
-		os=nextstep2
+	-nova*)
+		os=-rtmk-nova
+		;;
+	-ns2)
+		os=-nextstep2
+		;;
+	-nsk*)
+		os=-nsk
 		;;
 	# Preserve the version number of sinix5.
-	sinix5.*)
+	-sinix5.*)
 		os=`echo $os | sed -e 's|sinix|sysv|'`
 		;;
-	sinix*)
-		os=sysv4
+	-sinix*)
+		os=-sysv4
+		;;
+	-tpf*)
+		os=-tpf
+		;;
+	-triton*)
+		os=-sysv3
 		;;
-	tpf*)
-		os=tpf
+	-oss*)
+		os=-sysv3
 		;;
-	triton*)
-		os=sysv3
+	-svr4*)
+		os=-sysv4
 		;;
-	oss*)
-		os=sysv3
+	-svr3)
+		os=-sysv3
 		;;
-	svr4*)
-		os=sysv4
+	-sysvr4)
+		os=-sysv4
 		;;
-	svr3)
-		os=sysv3
+	# This must come after -sysvr4.
+	-sysv*)
 		;;
-	sysvr4)
-		os=sysv4
+	-ose*)
+		os=-ose
 		;;
-	ose*)
-		os=ose
+	-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
+		os=-mint
 		;;
-	*mint | mint[0-9]* | *MiNT | MiNT[0-9]*)
-		os=mint
+	-zvmoe)
+		os=-zvmoe
 		;;
-	dicos*)
-		os=dicos
+	-dicos*)
+		os=-dicos
 		;;
-	pikeos*)
+	-pikeos*)
 		# Until real need of OS specific support for
 		# particular features comes up, bare metal
 		# configurations are quite functional.
-		case $cpu in
+		case $basic_machine in
 		    arm*)
-			os=eabi
+			os=-eabi
 			;;
 		    *)
-			os=elf
+			os=-elf
 			;;
 		esac
 		;;
+	-nacl*)
+		;;
+	-ios)
+		;;
+	-none)
+		;;
 	*)
-		# No normalization, but not necessarily accepted, that comes below.
+		# Get rid of the `-' at the beginning of $os.
+		os=`echo $os | sed 's/[^-]*-//'`
+		echo Invalid configuration \`"$1"\': system \`"$os"\' not recognized 1>&2
+		exit 1
 		;;
 esac
-
 else
 
 # Here we handle the default operating systems that come with various machines.
@@ -1499,352 +1545,258 @@ else
 # will signal an error saying that MANUFACTURER isn't an operating
 # system, and we'll never get to this point.
 
-kernel=
-case $cpu-$vendor in
+case $basic_machine in
 	score-*)
-		os=elf
+		os=-elf
 		;;
 	spu-*)
-		os=elf
+		os=-elf
 		;;
 	*-acorn)
-		os=riscix1.2
+		os=-riscix1.2
 		;;
 	arm*-rebel)
-		kernel=linux
-		os=gnu
+		os=-linux
 		;;
 	arm*-semi)
-		os=aout
+		os=-aout
 		;;
 	c4x-* | tic4x-*)
-		os=coff
+		os=-coff
 		;;
 	c8051-*)
-		os=elf
-		;;
-	clipper-intergraph)
-		os=clix
+		os=-elf
 		;;
 	hexagon-*)
-		os=elf
+		os=-elf
 		;;
 	tic54x-*)
-		os=coff
+		os=-coff
 		;;
 	tic55x-*)
-		os=coff
+		os=-coff
 		;;
 	tic6x-*)
-		os=coff
+		os=-coff
 		;;
 	# This must come before the *-dec entry.
 	pdp10-*)
-		os=tops20
+		os=-tops20
 		;;
 	pdp11-*)
-		os=none
+		os=-none
 		;;
 	*-dec | vax-*)
-		os=ultrix4.2
+		os=-ultrix4.2
 		;;
 	m68*-apollo)
-		os=domain
+		os=-domain
 		;;
 	i386-sun)
-		os=sunos4.0.2
+		os=-sunos4.0.2
 		;;
 	m68000-sun)
-		os=sunos3
+		os=-sunos3
 		;;
 	m68*-cisco)
-		os=aout
+		os=-aout
 		;;
 	mep-*)
-		os=elf
+		os=-elf
 		;;
 	mips*-cisco)
-		os=elf
+		os=-elf
 		;;
 	mips*-*)
-		os=elf
+		os=-elf
 		;;
 	or32-*)
-		os=coff
+		os=-coff
 		;;
 	*-tti)	# must be before sparc entry or we get the wrong os.
-		os=sysv3
+		os=-sysv3
 		;;
 	sparc-* | *-sun)
-		os=sunos4.1.1
+		os=-sunos4.1.1
 		;;
 	pru-*)
-		os=elf
+		os=-elf
 		;;
 	*-be)
-		os=beos
+		os=-beos
 		;;
 	*-ibm)
-		os=aix
+		os=-aix
 		;;
 	*-knuth)
-		os=mmixware
+		os=-mmixware
 		;;
 	*-wec)
-		os=proelf
+		os=-proelf
 		;;
 	*-winbond)
-		os=proelf
+		os=-proelf
 		;;
 	*-oki)
-		os=proelf
+		os=-proelf
 		;;
 	*-hp)
-		os=hpux
+		os=-hpux
 		;;
 	*-hitachi)
-		os=hiux
+		os=-hiux
 		;;
 	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
-		os=sysv
+		os=-sysv
 		;;
 	*-cbm)
-		os=amigaos
+		os=-amigaos
 		;;
 	*-dg)
-		os=dgux
+		os=-dgux
 		;;
 	*-dolphin)
-		os=sysv3
+		os=-sysv3
 		;;
 	m68k-ccur)
-		os=rtu
+		os=-rtu
 		;;
 	m88k-omron*)
-		os=luna
+		os=-luna
 		;;
 	*-next)
-		os=nextstep
+		os=-nextstep
 		;;
 	*-sequent)
-		os=ptx
+		os=-ptx
 		;;
 	*-crds)
-		os=unos
+		os=-unos
 		;;
 	*-ns)
-		os=genix
+		os=-genix
 		;;
 	i370-*)
-		os=mvs
+		os=-mvs
 		;;
 	*-gould)
-		os=sysv
+		os=-sysv
 		;;
 	*-highlevel)
-		os=bsd
+		os=-bsd
 		;;
 	*-encore)
-		os=bsd
+		os=-bsd
 		;;
 	*-sgi)
-		os=irix
+		os=-irix
 		;;
 	*-siemens)
-		os=sysv4
+		os=-sysv4
 		;;
 	*-masscomp)
-		os=rtu
+		os=-rtu
 		;;
 	f30[01]-fujitsu | f700-fujitsu)
-		os=uxpv
+		os=-uxpv
 		;;
 	*-rom68k)
-		os=coff
+		os=-coff
 		;;
 	*-*bug)
-		os=coff
+		os=-coff
 		;;
 	*-apple)
-		os=macos
+		os=-macos
 		;;
 	*-atari*)
-		os=mint
-		;;
-	*-wrs)
-		os=vxworks
+		os=-mint
 		;;
 	*)
-		os=none
+		os=-none
 		;;
 esac
-
 fi
 
-# Now, validate our (potentially fixed-up) OS.
-case $os in
-	# Sometimes we do "kernel-abi", so those need to count as OSes.
-	musl* | newlib* | uclibc*)
-		;;
-	# Likewise for "kernel-libc"
-	eabi | eabihf | gnueabi | gnueabihf)
-		;;
-	# Now accept the basic system types.
-	# The portable systems comes first.
-	# Each alternative MUST end in a * to match a version number.
-	gnu* | android* | bsd* | mach* | minix* | genix* | ultrix* | irix* \
-	     | *vms* | esix* | aix* | cnk* | sunos | sunos[34]* \
-	     | hpux* | unos* | osf* | luna* | dgux* | auroraux* | solaris* \
-	     | sym* |  plan9* | psp* | sim* | xray* | os68k* | v88r* \
-	     | hiux* | abug | nacl* | netware* | windows* \
-	     | os9* | macos* | osx* | ios* \
-	     | mpw* | magic* | mmixware* | mon960* | lnews* \
-	     | amigaos* | amigados* | msdos* | newsos* | unicos* | aof* \
-	     | aos* | aros* | cloudabi* | sortix* | twizzler* \
-	     | nindy* | vxsim* | vxworks* | ebmon* | hms* | mvs* \
-	     | clix* | riscos* | uniplus* | iris* | isc* | rtu* | xenix* \
-	     | mirbsd* | netbsd* | dicos* | openedition* | ose* \
-	     | bitrig* | openbsd* | solidbsd* | libertybsd* | os108* \
-	     | ekkobsd* | freebsd* | riscix* | lynxos* | os400* \
-	     | bosx* | nextstep* | cxux* | aout* | elf* | oabi* \
-	     | ptx* | coff* | ecoff* | winnt* | domain* | vsta* \
-	     | udi* | lites* | ieee* | go32* | aux* | hcos* \
-	     | chorusrdb* | cegcc* | glidix* \
-	     | cygwin* | msys* | pe* | moss* | proelf* | rtems* \
-	     | midipix* | mingw32* | mingw64* | mint* \
-	     | uxpv* | beos* | mpeix* | udk* | moxiebox* \
-	     | interix* | uwin* | mks* | rhapsody* | darwin* \
-	     | openstep* | oskit* | conix* | pw32* | nonstopux* \
-	     | storm-chaos* | tops10* | tenex* | tops20* | its* \
-	     | os2* | vos* | palmos* | uclinux* | nucleus* | morphos* \
-	     | scout* | superux* | sysv* | rtmk* | tpf* | windiss* \
-	     | powermax* | dnix* | nx6 | nx7 | sei* | dragonfly* \
-	     | skyos* | haiku* | rdos* | toppers* | drops* | es* \
-	     | onefs* | tirtos* | phoenix* | fuchsia* | redox* | bme* \
-	     | midnightbsd* | amdhsa* | unleashed* | emscripten* | wasi* \
-	     | nsk* | powerunix* | genode* | zvmoe* )
-		;;
-	# This one is extra strict with allowed versions
-	sco3.2v2 | sco3.2v[4-9]* | sco5v6*)
-		# Don't forget version if it is 3.2v4 or newer.
-		;;
-	none)
-		;;
-	*)
-		echo Invalid configuration \`"$1"\': OS \`"$os"\' not recognized 1>&2
-		exit 1
-		;;
-esac
-
-# As a final step for OS-related things, validate the OS-kernel combination
-# (given a valid OS), if there is a kernel.
-case $kernel-$os in
-	linux-gnu* | linux-dietlibc* | linux-android* | linux-newlib* | linux-musl* | linux-uclibc* )
-		;;
-	-dietlibc* | -newlib* | -musl* | -uclibc* )
-		# These are just libc implementations, not actual OSes, and thus
-		# require a kernel.
-		echo "Invalid configuration \`$1': libc \`$os' needs explicit kernel." 1>&2
-		exit 1
-		;;
-	kfreebsd*-gnu* | kopensolaris*-gnu*)
-		;;
-	nto-qnx*)
-		;;
-	*-eabi* | *-gnueabi*)
-		;;
-	-*)
-		# Blank kernel with real OS is always fine.
-		;;
-	*-*)
-		echo "Invalid configuration \`$1': Kernel \`$kernel' not known to work with OS \`$os'." 1>&2
-		exit 1
-		;;
-esac
-
 # Here we handle the case where we know the os, and the CPU type, but not the
 # manufacturer.  We pick the logical manufacturer.
-case $vendor in
-	unknown)
-		case $cpu-$os in
-			*-riscix*)
+vendor=unknown
+case $basic_machine in
+	*-unknown)
+		case $os in
+			-riscix*)
 				vendor=acorn
 				;;
-			*-sunos*)
+			-sunos*)
 				vendor=sun
 				;;
-			*-cnk* | *-aix*)
+			-cnk*|-aix*)
 				vendor=ibm
 				;;
-			*-beos*)
+			-beos*)
 				vendor=be
 				;;
-			*-hpux*)
+			-hpux*)
 				vendor=hp
 				;;
-			*-mpeix*)
+			-mpeix*)
 				vendor=hp
 				;;
-			*-hiux*)
+			-hiux*)
 				vendor=hitachi
 				;;
-			*-unos*)
+			-unos*)
 				vendor=crds
 				;;
-			*-dgux*)
+			-dgux*)
 				vendor=dg
 				;;
-			*-luna*)
+			-luna*)
 				vendor=omron
 				;;
-			*-genix*)
+			-genix*)
 				vendor=ns
 				;;
-			*-clix*)
-				vendor=intergraph
-				;;
-			*-mvs* | *-opened*)
-				vendor=ibm
-				;;
-			*-os400*)
+			-mvs* | -opened*)
 				vendor=ibm
 				;;
-			s390-* | s390x-*)
+			-os400*)
 				vendor=ibm
 				;;
-			*-ptx*)
+			-ptx*)
 				vendor=sequent
 				;;
-			*-tpf*)
+			-tpf*)
 				vendor=ibm
 				;;
-			*-vxsim* | *-vxworks* | *-windiss*)
+			-vxsim* | -vxworks* | -windiss*)
 				vendor=wrs
 				;;
-			*-aux*)
+			-aux*)
 				vendor=apple
 				;;
-			*-hms*)
+			-hms*)
 				vendor=hitachi
 				;;
-			*-mpw* | *-macos*)
+			-mpw* | -macos*)
 				vendor=apple
 				;;
-			*-*mint | *-mint[0-9]* | *-*MiNT | *-MiNT[0-9]*)
+			-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
 				vendor=atari
 				;;
-			*-vos*)
+			-vos*)
 				vendor=stratus
 				;;
 		esac
+		basic_machine=`echo "$basic_machine" | sed "s/unknown/$vendor/"`
 		;;
 esac
 
-echo "$cpu-$vendor-${kernel:+$kernel-}$os"
+echo "$basic_machine$os"
 exit
 
 # Local variables:
-# eval: (add-hook 'before-save-hook 'time-stamp)
+# eval: (add-hook 'write-file-functions 'time-stamp)
 # time-stamp-start: "timestamp='"
 # time-stamp-format: "%:y-%02m-%02d"
 # time-stamp-end: "'"
diff --git a/configure.ac b/configure.ac
index a7974b0..06118fa 100644
--- a/configure.ac
+++ b/configure.ac
@@ -16,7 +16,7 @@
 # Process this file with autoconf to produce a configure script.
 
 # Require Autoconf 2.71 for repeatability in CI
-AC_PREREQ([2.71])
+AC_PREREQ([2.61])
 AC_INIT([OCaml],
         [OCAML__VERSION],
         [caml-list@inria.fr],
@@ -1079,7 +1079,8 @@ AS_IF([test x"$supports_shared_libraries" = 'xtrue'],
     [aarch64-*-freebsd*], [natdynlink=true],
     [aarch64-*-openbsd*], [natdynlink=true],
     [aarch64-*-netbsd*], [natdynlink=true],
-    [riscv*-*-linux*], [natdynlink=true])])
+    [riscv*-*-linux*], [natdynlink=true],
+    [loongarch*-*-linux*], [natdynlink=true])])
 
 AS_CASE([$enable_native_toplevel,$natdynlink],
   [yes,false],
@@ -1199,7 +1200,9 @@ AS_CASE([$host],
   [x86_64-*-cygwin*],
     [arch=amd64; system=cygwin],
   [riscv64-*-linux*],
-    [arch=riscv; model=riscv64; system=linux]
+    [arch=riscv; model=riscv64; system=linux],
+  [loongarch64-*-linux*],
+    [has_native_backend=yes; arch=loongarch64; system=linux]
 )
 
 AS_CASE([$ccomptype],
@@ -1302,7 +1305,7 @@ default_aspp="$CC -c"
 AS_CASE([$as_target,$ocaml_cv_cc_vendor],
   [*-*-linux*,gcc-*],
     [AS_CASE([$as_cpu],
-      [x86_64|arm*|aarch64*|i[[3-6]]86|riscv*],
+      [x86_64|arm*|aarch64*|i[[3-6]]86|riscv*|loongarch*],
         [default_as="${toolpref}as"])],
   [i686-pc-windows,*],
     [default_as="ml -nologo -coff -Cp -c -Fo"
@@ -1891,7 +1894,7 @@ AC_MSG_CHECKING([whether stack overflows can be detected])
 
 AS_CASE([$arch,$system],
   [i386,linux_elf|amd64,linux|amd64,macosx \
-    |amd64,openbsd|i386,bsd_elf|arm64,linux|arm64,macosx],
+    |amd64,openbsd|i386,bsd_elf|arm64,linux|arm64,macosx|loongarch64,linux],
     [AC_DEFINE([HAS_STACK_OVERFLOW_DETECTION])
     AC_MSG_RESULT([yes])],
   [AC_MSG_RESULT([no])])
diff --git a/runtime/caml/domain_state.tbl b/runtime/caml/domain_state.tbl
index e3e574d..5361bcb 100644
--- a/runtime/caml/domain_state.tbl
+++ b/runtime/caml/domain_state.tbl
@@ -14,116 +14,163 @@
 /*                                                                        */
 /**************************************************************************/
 
+#define domain_field_caml_young_limit 0
 DOMAIN_STATE(atomic_uintnat, young_limit)
 /* Minor heap limit. Typically young_limit == young_start, but this field is set
  * by other domains to signal this domain by causing a spurious allocation
  * failure. */
 
+#define domain_field_caml_young_ptr 8
 DOMAIN_STATE(value*, young_ptr)
 /* Minor heap pointer */
 
+#define domain_field_caml_young_start 16
 DOMAIN_STATE(value*, young_start)
 /* Start of the minor heap */
 
+#define domain_field_caml_young_end 24
 DOMAIN_STATE(value*, young_end)
 /* End of the minor heap. always(young_start <= young_ptr <= young_end) */
 
+#define domain_field_caml_current_stack 32
 DOMAIN_STATE(struct stack_info*, current_stack)
 /* Current stack */
 
+#define domain_field_caml_exn_handler 40
 DOMAIN_STATE(void*, exn_handler)
 /* Pointer into the current stack */
 
+#define domain_field_caml_action_pending 48
 DOMAIN_STATE(int, action_pending)
 /* Whether we are due to start the processing of delayable pending
    actions. See runtime/signal.c. */
 
+#define domain_field_caml_c_stack 56
 DOMAIN_STATE(struct c_stack_link*, c_stack)
 /* The C stack associated with this domain.
  * Used by this domain to perform external calls. */
 
+#define domain_field_caml_stack_cache 64
 DOMAIN_STATE(struct stack_info**, stack_cache)
 /* This is a list of freelist buckets of stacks */
 
+#define domain_field_caml_gc_regs_buckets 72
 DOMAIN_STATE(value*, gc_regs_buckets)
 
+#define domain_field_caml_gc_regs 80
 DOMAIN_STATE(value*, gc_regs)
 
+#define domain_field_caml_minor_tables 88
 DOMAIN_STATE(struct caml_minor_tables*, minor_tables)
 
+#define domain_field_caml_mark_stack 96
 DOMAIN_STATE(struct mark_stack*, mark_stack)
 /* Mark stack */
 
+#define domain_field_caml_marking_done 104
 DOMAIN_STATE(uintnat, marking_done)
 /* Is marking done for the current major cycle. */
 
+#define domain_field_caml_sweeping_done 112
 DOMAIN_STATE(uintnat, sweeping_done)
 /* Is sweeping done for the current major cycle. */
 
+#define domain_field_caml_allocated_words 120
 DOMAIN_STATE(uintnat, allocated_words)
 
+#define domain_field_caml_swept_words 128
 DOMAIN_STATE(uintnat, swept_words)
 
+#define domain_field_caml_major_work_computed 136
 DOMAIN_STATE(intnat, major_work_computed)
 /* total work accumulated in this GC clock cycle (in words) */
 
+#define domain_field_caml_major_work_todo 144
 DOMAIN_STATE(intnat, major_work_todo)
 /* balance of work to do in this GC clock cycle (in words)
  *  positive: we need to do this amount of work to finish the slice
  *  negative: we have done more than we need and this is credit
  */
 
+#define domain_field_caml_major_gc_clock 152
 DOMAIN_STATE(double, major_gc_clock)
 
+#define domain_field_caml_local_roots 160
 DOMAIN_STATE(struct caml__roots_block*, local_roots)
 
+#define domain_field_caml_ephe_info 168
 DOMAIN_STATE(struct caml_ephe_info*, ephe_info)
 
+#define domain_field_caml_final_info 176
 DOMAIN_STATE(struct caml_final_info*, final_info)
 
+#define domain_field_caml_backtrace_pos 184
 DOMAIN_STATE(intnat, backtrace_pos)
 
+#define domain_field_caml_backtrace_active 192
 DOMAIN_STATE(intnat, backtrace_active)
 
+#define domain_field_caml_backtrace_buffer 200
 DOMAIN_STATE(backtrace_slot*, backtrace_buffer)
 
+#define domain_field_caml_backtrace_last_exn 208
 DOMAIN_STATE(value, backtrace_last_exn)
 
+#define domain_field_caml_compare_unordered 216
 DOMAIN_STATE(intnat, compare_unordered)
 
+#define domain_field_caml_oo_next_id_local 224
 DOMAIN_STATE(uintnat, oo_next_id_local)
 
+#define domain_field_caml_requested_major_slice 232
 DOMAIN_STATE(uintnat, requested_major_slice)
 
+#define domain_field_caml_requested_minor_gc 240
 DOMAIN_STATE(uintnat, requested_minor_gc)
 
+#define domain_field_caml_requested_external_interrupt 248
 DOMAIN_STATE(atomic_uintnat, requested_external_interrupt)
 
+#define domain_field_caml_parser_trace 256
 DOMAIN_STATE(int, parser_trace)
 /* See parsing.c */
 
+#define domain_field_caml_minor_heap_wsz 264
 DOMAIN_STATE(asize_t, minor_heap_wsz)
 
+#define domain_field_caml_shared_heap 272
 DOMAIN_STATE(struct caml_heap_state*, shared_heap)
 
+#define domain_field_caml_id 280
 DOMAIN_STATE(int, id)
 
+#define domain_field_caml_unique_id 288
 DOMAIN_STATE(int, unique_id)
 
+#define domain_field_caml_pools_to_rescan 296
 DOMAIN_STATE(struct pool**, pools_to_rescan)
+#define domain_field_caml_pools_to_rescan_len 304
 DOMAIN_STATE(int, pools_to_rescan_len)
+#define domain_field_caml_pools_to_rescan_count 312
 DOMAIN_STATE(int, pools_to_rescan_count)
 
+#define domain_field_caml_dls_root 320
 DOMAIN_STATE(value, dls_root)
 /* Domain-local state */
 
+#define domain_field_caml_extra_heap_resources 328
 DOMAIN_STATE(double, extra_heap_resources)
+#define domain_field_caml_extra_heap_resources_minor 336
 DOMAIN_STATE(double, extra_heap_resources_minor)
 
+#define domain_field_caml_dependent_size 344
 DOMAIN_STATE(uintnat, dependent_size)
+#define domain_field_caml_dependent_allocated 352
 DOMAIN_STATE(uintnat, dependent_allocated)
 
+#define domain_field_caml_extern_state 360
 DOMAIN_STATE(struct caml_extern_state*, extern_state)
+#define domain_field_caml_intern_state 368
 DOMAIN_STATE(struct caml_intern_state*, intern_state)
 
 /*****************************************************************************/
@@ -131,23 +178,35 @@ DOMAIN_STATE(struct caml_intern_state*, intern_state)
 /* These stats represent only the current domain's respective values. */
 /* Use the Gc module to get aggregated total program stats. */
 /*****************************************************************************/
+#define domain_field_caml_stat_minor_words 376
 DOMAIN_STATE(uintnat, stat_minor_words)
+#define domain_field_caml_stat_promoted_words 384
 DOMAIN_STATE(uintnat, stat_promoted_words)
+#define domain_field_caml_stat_major_words 392
 DOMAIN_STATE(uintnat, stat_major_words)
+#define domain_field_caml_stat_minor_collections 400
 DOMAIN_STATE(intnat, stat_minor_collections)
+#define domain_field_caml_stat_forced_major_collections 408
 DOMAIN_STATE(intnat, stat_forced_major_collections)
+#define domain_field_caml_stat_blocks_marked 416
 DOMAIN_STATE(uintnat, stat_blocks_marked)
 
+#define domain_field_caml_inside_stw_handler 424
 DOMAIN_STATE(int, inside_stw_handler)
 /* whether or not a domain is inside of a stop-the-world handler
    this is used for several debug assertions inside of methods
    that can only be called from either in or outside this state. */
 
+#define domain_field_caml_trap_sp_off 432
 DOMAIN_STATE(intnat, trap_sp_off)
+#define domain_field_caml_trap_barrier_off 440
 DOMAIN_STATE(intnat, trap_barrier_off)
+#define domain_field_caml_trap_barrier_block 448
 DOMAIN_STATE(int64_t, trap_barrier_block)
+#define domain_field_caml_external_raise 456
 DOMAIN_STATE(struct caml_exception_context*, external_raise)
 /* Bytecode TLS vars, not used for native code */
 
+#define domain_field_caml_extra_params 464
 DOMAIN_STATE(extra_params_area, extra_params)
 /* This member must occur last, because it is an array, not a scalar */
diff --git a/runtime/caml/stack.h b/runtime/caml/stack.h
index 0c2e0b2..ebdc1d5 100644
--- a/runtime/caml/stack.h
+++ b/runtime/caml/stack.h
@@ -70,6 +70,17 @@
 #define Saved_return_address(sp) *((intnat *)((sp) - 8))
 #endif
 
+#ifdef TARGET_loongarch64
+/* Size of the gc_regs structure, in words.
+   See loongarch64.S and loongarch64/proc.ml for the indices */
+#define Wosize_gc_regs (2 + 23 /* int regs */ + 24 /* float regs */)
+#define Saved_return_address(sp) *((intnat *)((sp) - 8))
+/* LoongArch does not use a frame pointer, but requires the stack to be
+   16-aligned, so when pushing the return address to the stack there
+   is an extra word of padding after it that needs to be skipped when
+   walking the stack. */
+#define Pop_frame_pointer(sp) sp += sizeof(value)
+#endif
 /* Declaration of variables used in the asm code */
 extern value * caml_globals[];
 extern intnat caml_globals_inited;
diff --git a/runtime/loongarch64.S b/runtime/loongarch64.S
new file mode 100644
index 0000000..aed63f8
--- /dev/null
+++ b/runtime/loongarch64.S
@@ -0,0 +1,828 @@
+/**************************************************************************/
+/*                                                                        */
+/*                                 OCaml                                  */
+/*                                                                        */
+/*                    yala <zhaojunchao@loongson.cn>                      */
+/*                                                                        */
+/*                   Copyright © 2008-2023 LOONGSON                       */
+/*                                                                        */
+/*   All rights reserved.  This file is distributed under the terms of    */
+/*   the GNU Lesser General Public License version 2.1, with the          */
+/*   $special exception on linking described in the file LICENSE.          */
+/*                                                                        */
+/**************************************************************************/
+
+/* Asm part of the runtime system, LoongArch processor, 64-bit mode */
+/* Must be preprocessed by cpp */
+
+#include "caml/m.h"
+
+#define DOMAIN_STATE_PTR $s8
+#define TRAP_PTR $s1
+#define ALLOC_PTR $s7
+#define ADDITIONAL_ARG $t2
+#define STACK_ARG_BEGIN $s3
+#define STACK_ARG_END $s4
+#define TMP $t0
+#define TMP2 $t1
+
+#define C_ARG_1 $a0
+#define C_ARG_2 $a1
+#define C_ARG_3 $a2
+#define C_ARG_4 $a3
+
+/* Support for CFI directives */
+//FIXME
+#define CFI_STARTPROC
+#define CFI_ENDPROC
+#define CFI_ADJUST(n)
+#define CFI_REGISTER(r1,r2)
+#define CFI_OFFSET(r,n)
+#define CFI_DEF_CFA_REGISTER(r)
+#define CFI_REMEMBER_STATE
+#define CFI_RESTORE_STATE
+
+        .set    domain_curr_field, 0
+        .set    domain_curr_cnt, 0
+#define DOMAIN_STATE(c_type, name) \
+	/*
+        .equ    domain_field_caml_##name, domain_curr_field ; \
+        .set    domain_curr_cnt, domain_curr_cnt + 1;    \
+        .set    domain_curr_field, domain_curr_cnt*8
+	*/
+#include "../runtime/caml/domain_state.tbl"
+#undef DOMAIN_STATE
+
+#define Caml_state(var) DOMAIN_STATE_PTR, domain_field_caml_##var
+
+/* Globals and labels */
+#define L(lbl) .L##lbl
+
+#define FUNCTION(name) \
+        .align 2; \
+        .globl name; \
+        .type  name, @function; \
+name:; \
+        CFI_STARTPROC
+
+#define END_FUNCTION(name) \
+        CFI_ENDPROC; \
+        .size name, .-name
+
+#if defined(__PIC__)
+#define PLT(r) %plt(r)
+#else
+#define PLT(r) r
+#endif
+
+#define OBJECT(name) \
+        .data; \
+        .align  3; \
+        .globl  name; \
+        .type   name, @object; \
+name:
+#define END_OBJECT(name) \
+        .size   name, .-name
+
+/* Stack switching operations */
+
+/* struct stack_info */
+#define Stack_sp(reg)           reg, 0
+#define Stack_exception(reg)    reg, 8
+#define Stack_handler(reg)      reg, 16
+#define Stack_handler_from_cont(reg) reg, 15
+
+/* struct c_stack_link */
+#define Cstack_stack(reg)       reg, 0
+#define Cstack_sp(reg)          reg, 8
+#define Cstack_prev(reg)        reg, 16
+
+/* struct stack_handler */
+#define Handler_value(reg)      reg, 0
+#define Handler_exception(reg)  reg, 8
+#define Handler_effect(reg)     reg, 16
+#define Handler_parent(reg)     reg, 24
+
+/* Switch from OCaml to C stack. */
+.macro SWITCH_OCAML_TO_C
+    /* Fill in Caml_state->current_stack->$sp */
+        ld.d      TMP, Caml_state(current_stack)
+        st.d      $sp, Stack_sp(TMP)
+    /* Fill in Caml_state->c_stack */
+        ld.d      TMP2, Caml_state(c_stack)
+        st.d      TMP, Cstack_stack(TMP2)
+        st.d      $sp, Cstack_sp(TMP2)
+    /* Switch to C stack */
+        move      $sp, TMP2
+        CFI_REMEMBER_STATE
+.endm
+
+/* Switch from C to OCaml stack. */
+.macro SWITCH_C_TO_OCAML
+        ld.d      $sp, Cstack_sp($sp)
+        CFI_RESTORE_STATE
+.endm
+
+/* Save all of the registers that may be in use to a free gc_regs bucket
+   and store ALLOC_PTR and TRAP_PTR back to Caml_state
+   At the end the saved registers are placed in Caml_state(gc_regs)
+ */
+.macro SAVE_ALL_REGS
+    /* First, save the young_ptr & exn_handler */
+        st.d      ALLOC_PTR, Caml_state(young_ptr)
+        st.d      TRAP_PTR, Caml_state(exn_handler)
+    /* Now, use TMP to point to the gc_regs bucket */
+        ld.d      TMP, Caml_state(gc_regs_buckets)
+		ld.d      TMP2, TMP, 0  /* next ptr */
+        st.d      TMP2, Caml_state(gc_regs_buckets)
+    /* Save allocatable integer registers Must be in
+    the same order as proc.ml int_reg_name*/
+        st.d      $a0, TMP, 2*8
+        st.d      $a1, TMP, 3*8
+        st.d      $a2, TMP, 4*8
+        st.d      $a3, TMP, 5*8
+        st.d      $a4, TMP, 6*8
+        st.d      $a5, TMP, 7*8
+        st.d      $a6, TMP, 8*8
+        st.d      $a7, TMP, 9*8
+        st.d      $s2, TMP, 10*8
+        st.d      $s3, TMP, 11*8
+        st.d      $s4, TMP, 12*8
+        st.d      $s5, TMP, 13*8
+        st.d      $s6, TMP, 14*8
+        st.d      $t2, TMP, 15*8
+        st.d      $t3, TMP, 16*8
+        st.d      $t4, TMP, 17*8
+        st.d      $t5, TMP, 18*8
+        st.d      $t6, TMP, 19*8
+        st.d      $t7, TMP, 20*8
+        st.d      $t8, TMP, 21*8
+        st.d      $s0, TMP, 22*8
+    /* Save caller-save floating-point registers
+       (callee-saves are preserved by C functions) */
+        fst.d     $ft0, TMP, 23*8
+        fst.d     $ft1, TMP, 24*8
+        fst.d     $ft2, TMP, 25*8
+        fst.d     $ft3, TMP, 26*8
+        fst.d     $ft4, TMP, 27*8
+        fst.d     $ft5, TMP, 28*8
+        fst.d     $ft6, TMP, 29*8
+        fst.d     $ft7, TMP, 30*8
+        fst.d     $fa0, TMP, 31*8
+        fst.d     $fa1, TMP, 32*8
+        fst.d     $fa2, TMP, 33*8
+        fst.d     $fa3, TMP, 34*8
+        fst.d     $fa4, TMP, 35*8
+        fst.d     $fa5, TMP, 36*8
+        fst.d     $fa6, TMP, 37*8
+        fst.d     $fa7, TMP, 38*8
+        fst.d     $ft8, TMP, 39*8
+        fst.d     $ft9, TMP, 40*8
+        fst.d     $ft10, TMP, 41*8
+        fst.d     $ft11, TMP, 42*8
+        fst.d     $ft12, TMP, 43*8
+        fst.d     $ft13, TMP, 44*8
+        fst.d     $ft14, TMP, 45*8
+        fst.d     $ft15, TMP, 46*8
+        addi.d    TMP, TMP, 16
+        st.d      TMP, Caml_state(gc_regs)
+.endm
+
+/* Undo SAVE_ALL_REGS by loading the registers saved in Caml_state(gc_regs)
+   and refreshing ALLOC_PTR & TRAP_PTR from Caml_state */
+.macro RESTORE_ALL_REGS
+    /* Restore $a0, $a1, freeing up the next ptr slot */
+        ld.d      TMP, Caml_state(gc_regs)
+        addi.d    TMP, TMP, -16
+    /* Restore registers */
+        ld.d      $a0, TMP, 2*8
+        ld.d      $a1, TMP, 3*8
+        ld.d      $a2, TMP, 4*8
+        ld.d      $a3, TMP, 5*8
+        ld.d      $a4, TMP, 6*8
+        ld.d      $a5, TMP, 7*8
+        ld.d      $a6, TMP, 8*8
+        ld.d      $a7, TMP, 9*8
+        ld.d      $s2, TMP, 10*8
+        ld.d      $s3, TMP, 11*8
+        ld.d      $s4, TMP, 12*8
+        ld.d      $s5, TMP, 13*8
+        ld.d      $s6, TMP, 14*8
+        ld.d      $t2, TMP, 15*8
+        ld.d      $t3, TMP, 16*8
+        ld.d      $t4, TMP, 17*8
+        ld.d      $t5, TMP, 18*8
+        ld.d      $t6, TMP, 19*8
+        ld.d      $t7, TMP, 20*8
+        ld.d      $t8, TMP, 21*8
+        ld.d      $s0, TMP, 22*8
+        fld.d     $ft0, TMP, 23*8
+        fld.d     $ft1, TMP, 24*8
+        fld.d     $ft2, TMP, 25*8
+        fld.d     $ft3, TMP, 26*8
+        fld.d     $ft4, TMP, 27*8
+        fld.d     $ft5, TMP, 28*8
+        fld.d     $ft6, TMP, 29*8
+        fld.d     $ft7, TMP, 30*8
+        fld.d     $fa0, TMP, 31*8
+        fld.d     $fa1, TMP, 32*8
+        fld.d     $fa2, TMP, 33*8
+        fld.d     $fa3, TMP, 34*8
+        fld.d     $fa4, TMP, 35*8
+        fld.d     $fa5, TMP, 36*8
+        fld.d     $fa6, TMP, 37*8
+        fld.d     $fa7, TMP, 38*8
+        fld.d     $ft8, TMP, 39*8
+        fld.d     $ft9, TMP, 40*8
+        fld.d     $ft10, TMP, 41*8
+        fld.d     $ft11, TMP, 42*8
+        fld.d     $ft12, TMP, 43*8
+        fld.d     $ft13, TMP, 44*8
+        fld.d     $ft14, TMP, 45*8
+        fld.d     $ft15, TMP, 46*8
+    /* Put gc_regs struct back in bucket linked list */
+        ld.d      TMP2, Caml_state(gc_regs_buckets)
+		st.d      TMP2, TMP, 0  /* next ptr */
+        st.d      TMP, Caml_state(gc_regs_buckets)
+    /* Reload new allocation pointer & exn handler */
+        ld.d      ALLOC_PTR, Caml_state(young_ptr)
+        ld.d      TRAP_PTR, Caml_state(exn_handler)
+.endm
+
+        .section        .text
+/* Invoke the garbage collector. */
+
+        .globl  caml_system__code_begin
+caml_system__code_begin:
+
+FUNCTION(caml_call_realloc_stack)
+    /* Save return address */
+        CFI_OFFSET($ra, -8)
+        addi.d    $sp, $sp, -16
+		st.d      $ra, $sp, 8 
+        //CFI_ADJUST(16)
+    /* Save all registers (including ALLOC_PTR & TRAP_PTR) */
+        SAVE_ALL_REGS
+		ld.d      C_ARG_1, $sp, 16  /* argument */
+        SWITCH_OCAML_TO_C
+        bl    PLT(caml_try_realloc_stack)
+        SWITCH_C_TO_OCAML
+        beqz    $a0, 1f
+        RESTORE_ALL_REGS
+    /* Free stack $space and return to caller */
+		ld.d      $ra, $sp, 8 
+        addi.d    $sp, $sp, 16
+        jr    $ra
+1:      RESTORE_ALL_REGS
+    /* Raise the Stack_overflow exception */
+		ld.d      $ra, $sp, 8 
+        addi.d    $sp, $sp, 16
+        addi.d    $sp, $sp, 16 /* pop argument */
+        la.global      $a0, caml_exn_Stack_overflow
+        b       caml_raise_exn
+END_FUNCTION(caml_call_realloc_stack)
+
+FUNCTION(caml_call_gc)
+L(caml_call_gc):
+    /* Save return address */
+        CFI_OFFSET($ra, -8)
+        addi.d    $sp, $sp, -16
+		st.d      $ra, $sp, 8 
+        CFI_ADJUST(16)
+    /* Store all registers (including ALLOC_PTR & TRAP_PTR) */
+        SAVE_ALL_REGS
+        SWITCH_OCAML_TO_C
+    /* Call the garbage collector */
+        bl    PLT(caml_garbage_collection)
+        SWITCH_C_TO_OCAML
+        RESTORE_ALL_REGS
+    /* Free stack $space and return to caller */
+		ld.d      $ra, $sp, 8 
+        addi.d    $sp, $sp, 16
+        jr    $ra
+END_FUNCTION(caml_call_gc)
+
+FUNCTION(caml_alloc1)
+        ld.d      TMP, Caml_state(young_limit)
+        addi.d    ALLOC_PTR, ALLOC_PTR, -16
+        bltu    ALLOC_PTR, TMP, L(caml_call_gc)
+        jr    $ra
+END_FUNCTION(caml_alloc1)
+
+FUNCTION(caml_alloc2)
+        ld.d      TMP, Caml_state(young_limit)
+        addi.d    ALLOC_PTR, ALLOC_PTR, -24
+        bltu    ALLOC_PTR, TMP, L(caml_call_gc)
+        jr    $ra
+END_FUNCTION(caml_alloc2)
+
+FUNCTION(caml_alloc3)
+        ld.d      TMP, Caml_state(young_limit)
+        addi.d    ALLOC_PTR, ALLOC_PTR, -32
+        bltu    ALLOC_PTR, TMP, L(caml_call_gc)
+        jr    $ra
+END_FUNCTION(caml_alloc3)
+
+FUNCTION(caml_allocN)
+        ld.d      TMP, Caml_state(young_limit)
+        sub.d     ALLOC_PTR, ALLOC_PTR, ADDITIONAL_ARG
+        bltu    ALLOC_PTR, TMP, L(caml_call_gc)
+        jr    $ra
+END_FUNCTION(caml_allocN)
+
+/* Call a C function from OCaml */
+/* Function to call is in ADDITIONAL_ARG */
+
+FUNCTION(caml_c_call)
+        CFI_OFFSET($ra, -8)
+        addi.d    $sp, $sp, -16
+		st.d      $ra, $sp, 8 
+        CFI_ADJUST(16)
+    /* Switch form OCaml to C */
+        SWITCH_OCAML_TO_C
+    /* Make the exception handler alloc ptr available to the C code */
+        st.d      ALLOC_PTR, Caml_state(young_ptr)
+        st.d      TRAP_PTR, Caml_state(exn_handler)
+    /* Call the function */
+        jirl    $ra, ADDITIONAL_ARG, 0
+    /* Reload alloc ptr */
+        ld.d      ALLOC_PTR, Caml_state(young_ptr)
+    /* Load ocaml stack */
+        SWITCH_C_TO_OCAML
+    /* Return */
+		ld.d      $ra, $sp, 8 
+        addi.d    $sp, $sp, 16
+        jr    $ra
+END_FUNCTION(caml_c_call)
+
+FUNCTION(caml_c_call_stack_args)
+    /* Arguments:
+        C arguments  : $a0 to a7, fa0 to fa7
+        C function   : ADDITIONAL_ARG
+        C stack args : begin=STACK_ARG_BEGIN
+                       end=STACK_ARG_END */
+        CFI_OFFSET($ra, -8)
+        addi.d    $sp, $sp, -16
+		st.d      $ra, $sp, 8 
+        CFI_ADJUST(16)
+    /* Switch from OCaml to C */
+        SWITCH_OCAML_TO_C
+    /* Make the exception handler alloc ptr available to the C code */
+        st.d      ALLOC_PTR, Caml_state(young_ptr)
+        st.d      TRAP_PTR, Caml_state(exn_handler)
+    /* Store $sp to restore after call */
+        move      $s2, $sp
+    /* Copy arguments from OCaml to C stack
+       NB: STACK_ARG_{BEGIN,END} are 16-byte aligned */
+1:      addi.d    STACK_ARG_END, STACK_ARG_END, -16
+        bltu    STACK_ARG_END, STACK_ARG_BEGIN, 2f
+		ld.d      TMP, STACK_ARG_END, 0 
+		ld.d      TMP2, STACK_ARG_END, 8 
+        addi.d    $sp, $sp, -16
+		st.d      TMP, $sp, 0 
+		st.d      TMP2, $sp, 8 
+        b       1b
+2:  /* Call the function */
+        jirl    $ra, ADDITIONAL_ARG, 0
+    /* Restore stack */
+        move      $sp, $s2
+    /* Reload alloc ptr */
+        ld.d      ALLOC_PTR, Caml_state(young_ptr)
+    /* Switch from C to OCaml */
+        SWITCH_C_TO_OCAML
+    /* Return */
+		ld.d      $ra, $sp, 8 
+        addi.d    $sp, $sp, 16
+        jr    $ra
+END_FUNCTION(caml_c_call_stack_args)
+
+/* Start the OCaml program */
+
+FUNCTION(caml_start_program)
+    /* domain state is passed as arg from C */
+        move      TMP, C_ARG_1
+        la.global      TMP2, caml_program
+
+/* Code shared with caml_callback* */
+/* Address of domain state is in TMP */
+/* Address of OCaml code to call is in TMP2 */
+/* Arguments to the OCaml code are in $a0...a7 */
+
+L(jump_to_caml):
+    /* Set up stack frame and save callee-save registers */
+        CFI_OFFSET($ra, -200)
+        addi.d    $sp, $sp, -208
+		st.d      $ra, $sp, 8 
+        CFI_ADJUST(208)
+        st.d      $s0, $sp, 2*8
+        st.d      $s1, $sp, 3*8
+        st.d      $s2, $sp, 4*8
+        st.d      $s3, $sp, 5*8
+        st.d      $s4, $sp, 6*8
+        st.d      $s5, $sp, 7*8
+        st.d      $s6, $sp, 8*8
+        st.d      $s7, $sp, 9*8
+        st.d      $s8, $sp, 10*8
+        st.d      $fp, $sp, 11*8
+        fst.d     $fs0, $sp, 14*8
+        fst.d     $fs1, $sp, 15*8
+        fst.d     $fs2, $sp, 16*8
+        fst.d     $fs3, $sp, 17*8
+        fst.d     $fs4, $sp, 18*8
+        fst.d     $fs5, $sp, 19*8
+        fst.d     $fs6, $sp, 20*8
+        fst.d     $fs7, $sp, 21*8
+    /* Load domain state pointer from argument */
+        move      DOMAIN_STATE_PTR, TMP
+    /* Reload allocation pointer */
+        ld.d      ALLOC_PTR, Caml_state(young_ptr)
+    /* Build (16-byte aligned) struct c_stack_link on the C stack */
+        ld.d      $t2, Caml_state(c_stack)
+        addi.d    $sp, $sp, -32
+        st.d      $t2, Cstack_prev($sp)
+        st.d      $zero, Cstack_stack($sp)
+        st.d      $zero, Cstack_sp($sp)
+        CFI_ADJUST(32)
+        st.d      $sp, Caml_state(c_stack)
+    /* Load the OCaml stack */
+        ld.d      $t2, Caml_state(current_stack)
+        ld.d      $t2, Stack_sp($t2)
+    /* Store the gc_regs for callbacks during a GC */
+        ld.d      $t3, Caml_state(gc_regs)
+        addi.d    $t2, $t2, -8
+		st.d      $t3, $t2, 0 
+    /* Store the stack pointer to allow DWARF unwind */
+        addi.d    $t2, $t2, -8
+		st.d      $sp, $t2, 0  /* C_stack_sp */
+    /* Setup a trap frame to catch exceptions escaping the OCaml code */
+        ld.d      $t3, Caml_state(exn_handler)
+        la.local      $t4, L(trap_handler)
+        addi.d    $t2, $t2, -16
+		st.d      $t3, $t2, 0 
+		st.d      $t4, $t2, 8 
+        move      TRAP_PTR, $t2
+    /* Switch stacks and call the OCaml code */
+        move      $sp, $t2
+        CFI_REMEMBER_STATE
+    /* Call the OCaml code */
+        jirl    $ra, TMP2, 0
+L(caml_retaddr):
+    /* Pop the trap frame, restoring Caml_state->exn_handler */
+		ld.d      $t2, $sp, 0 
+        addi.d    $sp, $sp, 16
+        CFI_ADJUST(-16)
+        st.d      $t2, Caml_state(exn_handler)
+L(return_result):
+    /* Restore GC regs */
+		ld.d      $t2, $sp, 0 
+		ld.d      $t3, $sp, 8 
+        addi.d    $sp, $sp, 16
+        CFI_ADJUST(-16)
+        st.d      $t3, Caml_state(gc_regs)
+    /* Update allocation pointer */
+        st.d      ALLOC_PTR, Caml_state(young_ptr)
+    /* Return to C stack */
+        ld.d      $t2, Caml_state(current_stack)
+        st.d      $sp, Stack_sp($t2)
+        ld.d      $t3, Caml_state(c_stack)
+        move      $sp, $t3
+        CFI_RESTORE_STATE
+    /* Pop the struct c_stack_link */
+        ld.d      $t2, Cstack_prev($sp)
+        addi.d    $sp, $sp, 32
+        CFI_ADJUST(-32)
+        st.d      $t2, Caml_state(c_stack)
+    /* Reload callee-save register and return address */
+        ld.d      $s0, $sp, 2*8
+        ld.d      $s1, $sp, 3*8
+        ld.d      $s2, $sp, 4*8
+        ld.d      $s3, $sp, 5*8
+        ld.d      $s4, $sp, 6*8
+        ld.d      $s5, $sp, 7*8
+        ld.d      $s6, $sp, 8*8
+        ld.d      $s7, $sp, 9*8
+        ld.d      $s8, $sp, 10*8
+        ld.d      $fp, $sp, 11*8
+        fld.d     $fs0, $sp, 14*8
+        fld.d     $fs1, $sp, 15*8
+        fld.d     $fs2, $sp, 16*8
+        fld.d     $fs3, $sp, 17*8
+        fld.d     $fs4, $sp, 18*8
+        fld.d     $fs5, $sp, 19*8
+        fld.d     $fs6, $sp, 20*8
+        fld.d     $fs7, $sp, 21*8
+        ld.d      $ra, $sp, 8
+        addi.d    $sp, $sp, 208
+        CFI_ADJUST(-208)
+    /* Return to C caller */
+        jr    $ra
+END_FUNCTION(caml_start_program)
+
+/* The trap handler */
+
+        .align  2
+L(trap_handler):
+        CFI_STARTPROC
+    /* Save exception pointer */
+        st.d      TRAP_PTR, Caml_state(exn_handler)
+    /* Encode exception pointer */
+        ori     $a0, $a0, 2
+    /* Return it */
+        b       L(return_result)
+        CFI_ENDPROC
+
+/* Exceptions */
+
+.macro JUMP_TO_TRAP_PTR
+    /* Cut stack at current trap handler */
+        move      $sp, TRAP_PTR
+    /* Pop previous handler and jump to it */
+		ld.d      TMP, $sp, 8 
+		ld.d      TRAP_PTR, $sp, 0 
+        addi.d    $sp, $sp, 16
+        jr      TMP
+.endm
+
+/* Raise an exception from OCaml */
+FUNCTION(caml_raise_exn)
+    /* Test if backtrace is active */
+        ld.d      TMP, Caml_state(backtrace_active)
+        bnez    TMP, 2f
+1:
+        JUMP_TO_TRAP_PTR
+2:  /* Zero backtrace_pos */
+        st.d      $zero, Caml_state(backtrace_pos)
+L(caml_reraise_exn_stash):
+    /* Preserve exception bucket in callee-save register $s2 */
+        move      $s2, $a0
+    /* Stash the backtrace */
+                                  /* arg1: exn bucket, already in $a0 */
+        move      $a1, $ra            /* arg2: pc of $raise */
+        move      $a2, $sp            /* arg3: $sp of $raise */
+        move      $a3, TRAP_PTR      /* arg4: $sp of handler */
+    /* Switch to C stack */
+        ld.d      TMP, Caml_state(c_stack)
+        move      $sp, TMP
+        bl    PLT(caml_stash_backtrace)
+    /* Restore exception bucket and $raise */
+        move      $a0, $s2
+        b       1b
+END_FUNCTION(caml_raise_exn)
+
+FUNCTION(caml_reraise_exn)
+        ld.d      TMP, Caml_state(backtrace_active)
+        bnez    TMP, L(caml_reraise_exn_stash)
+        JUMP_TO_TRAP_PTR
+END_FUNCTION(caml_reraise_exn)
+
+/* Raise an exception from C */
+
+FUNCTION(caml_raise_exception)
+    /* Load the domain state ptr */
+        move      DOMAIN_STATE_PTR, C_ARG_1
+    /* Load the exception bucket */
+        move      $a0, C_ARG_2
+    /* Reload trap ptr and alloc ptr */
+        ld.d      TRAP_PTR, Caml_state(exn_handler)
+        ld.d      ALLOC_PTR, Caml_state(young_ptr)
+    /* Discard the C stack pointer and reset to ocaml stack */
+        ld.d      TMP, Caml_state(current_stack)
+        ld.d      TMP, Stack_sp(TMP)
+        move      $sp, TMP
+    /* Restore frame and link on return to OCaml */
+		ld.d      $ra, $sp, 8 
+        addi.d    $sp, $sp, 16
+        b       caml_raise_exn
+END_FUNCTION(caml_raise_exception)
+
+/* Callback from C to OCaml */
+
+FUNCTION(caml_callback_asm)
+    /* Initial shuffling of arguments */
+    /* ($a0 = Caml_state, $a1 = closure, 0(a2) = first arg) */
+        move      TMP, $a0
+		ld.d      $a0, $a2, 0            /* $a0 = first arg */
+                                    /* $a1 = closure environment */
+		ld.d      TMP2, $a1, 0           /* code pointer */
+        b       L(jump_to_caml)
+END_FUNCTION(caml_callback_asm)
+
+FUNCTION(caml_callback2_asm)
+    /* Initial shuffling of arguments */
+    /* ($a0 = Caml_state, $a1 = closure, 0(a2) = arg1, 8(a2) = arg2) */
+        move      TMP, $a0
+        move      TMP2, $a1
+		ld.d      $a0, $a2, 0  /* $a0 = first arg */
+		ld.d      $a1, $a2, 8  /* $a1 = second arg */
+        move      $a2, TMP2   /* a2 = closure environment */
+        la.global      TMP2, caml_apply2
+        b       L(jump_to_caml)
+END_FUNCTION(caml_callback2_asm)
+
+FUNCTION(caml_callback3_asm)
+    /* Initial shuffling of arguments */
+    /* ($a0 = Caml_state, $a1 = closure, 0(a2) = arg1, 8(a2) = arg2,
+        16(a2) = arg3) */
+        move      TMP, $a0
+        move      $a3, $a1       /* a3 = closure environment */
+		ld.d      $a0, $a2, 0     /* $a0 = first arg */
+		ld.d      $a1, $a2, 8     /* $a1 = second arg */
+		ld.d      $a2, $a2, 16    /* a2 = third arg */
+        la.global      TMP2, caml_apply3
+        b       L(jump_to_caml)
+END_FUNCTION(caml_callback3_asm)
+
+/* Fibers */
+
+/* Switch between OCaml stacks. Clobbers TMP and switches TRAP_PTR
+   Preserves old_stack and new_stack registers */
+.macro SWITCH_OCAML_STACKS old_stack, new_stack
+    /* Save frame pointer and return address for old_stack */
+        addi.d    $sp, $sp, -16
+		st.d      $ra, $sp, 8 
+        CFI_ADJUST(16)
+    /* Save OCaml SP and exn_handler in the stack info */
+        st.d      $sp, Stack_sp(\old_stack)
+        st.d      TRAP_PTR, Stack_exception(\old_stack)
+    /* switch stacks */
+        st.d      \new_stack, Caml_state(current_stack)
+        ld.d      TMP, Stack_sp(\new_stack)
+        move      $sp, TMP
+    /* restore exn_handler for new stack */
+        ld.d      TRAP_PTR, Stack_exception(\new_stack)
+    /* Restore frame pointer and return address for new_stack */
+		ld.d      $ra, $sp, 8 
+        addi.d    $sp, $sp, 16
+.endm
+
+/*
+ * A continuation is a one word object that points to a fiber. A fiber [f] will
+ * point to its parent at Handler_parent(Stack_handler(f)). In the following,
+ * the [last_fiber] refers to the last fiber in the linked-list formed by the
+ * parent pointer.
+ */
+
+FUNCTION(caml_perform)
+    /*  $a0: effect to perform
+        $a1: freshly allocated continuation */
+        ld.d      $a2, Caml_state(current_stack) /* a2 := old stack */
+        addi.d    $a3, $a2, 1 /* a3 := Val_ptr(old stack) */
+		st.d      $a3, $a1, 0  /* Iniitalize continuation */
+L(do_perform):
+    /*  $a0: effect to perform
+        $a1: continuation
+        a2: old_stack
+        a3: last_fiber */
+
+        ld.d      $t3, Stack_handler($a2)  /* $t3 := old stack -> handler */
+        ld.d      $t4, Handler_parent($t3) /* t4 := parent stack */
+        beqz    $t4, 1f
+        SWITCH_OCAML_STACKS $a2, $t4
+    /*  we have to null the Handler_parent after the switch because
+        the Handler_parent is needed to unwind the stack for backtraces */
+        st.d      $zero, Handler_parent($t3) /* Set parent of performer to NULL */
+        ld.d      TMP, Handler_effect($t3)
+        move      $a2, $a3                 /* a2 := last_fiber */
+        move      $a3, TMP                /* a3 := effect handler */
+        b    PLT(caml_apply3)
+1:
+    /*  switch back to original performer before $raising Effect.Unhandled
+        (no-op unless this is a reperform) */
+		ld.d      $t4, $a1, 0  /* load performer stack from continuation */
+        addi.d    $t4, $t4, -1 /* t4 := Ptr_val(t4) */
+        ld.d      $t3, Caml_state(current_stack)
+        SWITCH_OCAML_STACKS $t3, $t4
+    /*  No parent stack. Raise Effect.Unhandled. */
+        la.global      ADDITIONAL_ARG, caml_raise_unhandled_effect
+        b       caml_c_call
+END_FUNCTION(caml_perform)
+
+FUNCTION(caml_reperform)
+    /*  $a0: effect to perform
+        $a1: continuation
+        a2: last_fiber */
+        ld.d      TMP, Stack_handler_from_cont($a2)
+        ld.d      $a2, Caml_state(current_stack) /* a2 := old stack */
+        st.d      $a2, Handler_parent(TMP) /* Append to last_fiber */
+        addi.d    $a3, $a2, 1 /* a3 (last_fiber) := Val_ptr(old stack) */
+        b       L(do_perform)
+END_FUNCTION(caml_reperform)
+
+FUNCTION(caml_resume)
+    /*  $a0: new fiber
+        $a1: fun
+        a2: arg */
+        addi.d    $a0, $a0, -1 /* $a0 = Ptr_val($a0) */
+		ld.d      $a3, $a1, 0   /* code pointer */
+    /* Check if stack null, then already used */
+        beqz    $a0, 2f
+    /* Find end of list of stacks (put in $t2) */
+        move      TMP, $a0
+1:      ld.d      $t2, Stack_handler(TMP)
+        ld.d      TMP, Handler_parent($t2)
+        bnez    TMP, 1b
+    /* Add current stack to the end */
+        ld.d      $t3, Caml_state(current_stack)
+        st.d      $t3, Handler_parent($t2)
+        SWITCH_OCAML_STACKS $t3, $a0
+        move      $a0, $a2
+        jr      $a3
+2:      la.global      ADDITIONAL_ARG, caml_raise_continuation_already_resumed
+        b       caml_c_call
+END_FUNCTION(caml_resume)
+
+/* Run a function on a new stack, then either
+   return the value or invoke exception handler */
+FUNCTION(caml_runstack)
+    /*  $a0: fiber
+        $a1: fun
+        a2: arg */
+        CFI_OFFSET($ra, -8)
+        addi.d    $sp, $sp, -16
+		st.d      $ra, $sp, 8 
+        CFI_ADJUST(16)
+        addi.d    $a0, $a0, -1  /* $a0 := Ptr_val($a0) */
+		ld.d      $a3, $a1, 0    /* code pointer */
+    /*  save old stack pointer and exception handler */
+        ld.d      $t2, Caml_state(current_stack) /* $t2 := old stack */
+        st.d      $sp, Stack_sp($t2)
+        st.d      TRAP_PTR, Stack_exception($t2)
+    /* Load new stack pointer and set parent */
+        ld.d      TMP, Stack_handler($a0)
+        st.d      $t2, Handler_parent(TMP)
+        st.d      $a0, Caml_state(current_stack)
+        ld.d      $t3, Stack_sp($a0) /* $t3 := $sp of new stack */
+    /* Create an exception handler on the target stack
+       after 16byte DWARF & gc_regs block (which is unused here) */
+        addi.d    $t3, $t3, -32
+        la.local      TMP, L(fiber_exn_handler)
+		st.d      TMP, $t3, 8 
+    /* link the previous exn_handler so that copying stacks works */
+        ld.d      TMP, Stack_exception($a0)
+		st.d      TMP, $t3, 0 
+        move      TRAP_PTR, $t3
+    /* Switch to the new stack */
+        move      $sp, $t3
+        CFI_REMEMBER_STATE
+    /* Call the function on the new stack */
+        move      $a0, $a2
+        jirl    $ra, $a3, 0
+L(frame_runstack):
+        addi.d    $t2, $sp, 32 /* $t2 := stack_handler */
+        ld.d      $s2, Handler_value($t2) /* saved across C call */
+1:
+        move      $s3, $a0     /* save return across C call */
+        ld.d      $a0, Caml_state(current_stack) /* arg to caml_free_stack */
+    /* restore parent stack and exn_handler into Caml_state */
+        ld.d      TMP, Handler_parent($t2)
+        st.d      TMP, Caml_state(current_stack)
+        ld.d      TRAP_PTR, Stack_exception(TMP)
+        st.d      TRAP_PTR, Caml_state(exn_handler)
+    /* free old stack by switching directly to c_stack;
+       is a no-alloc call */
+        ld.d      $s4, Stack_sp(TMP) /* saved across C call */
+        CFI_RESTORE_STATE
+        CFI_REMEMBER_STATE
+        ld.d      TMP, Caml_state(c_stack)
+        move      $sp, TMP
+        bl    PLT(caml_free_stack)
+    /* switch directly to parent stack with correct return */
+        move      $a0, $s3
+        move      $a1, $s2
+        move      $sp, $s4
+        CFI_RESTORE_STATE
+		ld.d      TMP, $s2, 0   /* code pointer */
+    /* Invoke handle_value (or handle_exn) */
+		ld.d      $ra, $sp, 8 
+        addi.d    $sp, $sp, 16
+        CFI_ADJUST(-16)
+        jr      TMP
+L(fiber_exn_handler):
+        addi.d    $t2, $sp, 16  /* $t2 := stack_handler */
+        ld.d      $s2, Handler_exception($t2)
+        b       1b
+END_FUNCTION(caml_runstack)
+
+FUNCTION(caml_ml_array_bound_error)
+    /* Load address of [caml_array_bound_error_asm] in ADDITIONAL_ARG */
+        la.global      ADDITIONAL_ARG, caml_array_bound_error_asm
+    /* Call that function */
+        b       caml_c_call
+END_FUNCTION(caml_ml_array_bound_error)
+
+        .globl  caml_system__code_end
+caml_system__code_end:
+
+/* GC roots for callback */
+
+        .section .data
+        .align  3
+        .globl  caml_system__frametable
+        .type   caml_system__frametable, @object
+caml_system__frametable:
+        .quad   1               /* one descriptor */
+        .quad   .Lcaml_retaddr  /* return address into callback */
+        .short  -1              /* negative frame size => use callback link */
+        .short  0               /* no roots */
+        .align  3
+        .size   caml_system__frametable, .-caml_system__frametable
diff --git a/testsuite/tools/asmgen_loongarch64.S b/testsuite/tools/asmgen_loongarch64.S
new file mode 100644
index 0000000..97fbeae
--- /dev/null
+++ b/testsuite/tools/asmgen_loongarch64.S
@@ -0,0 +1,75 @@
+/**************************************************************************/
+/*                                                                        */
+/*                                OCaml                                   */
+/*                                                                        */
+/*                Nicolas Ojeda Bar <n.oje.bar@gmail.com>                 */
+/*                                                                        */
+/*   Copyright 2019 Institut National de Recherche en Informatique et     */
+/*     en Automatique.                                                    */
+/*                                                                        */
+/*   All rights reserved.  This file is distributed under the terms of    */
+/*   the GNU Lesser General Public License version 2.1, with the          */
+/*   special exception on linking described in the file LICENSE.          */
+/*                                                                        */
+/**************************************************************************/
+
+#define STORE st.d
+#define LOAD ld.d
+
+        .globl  call_gen_code
+        .align  2
+call_gen_code:
+    /* Set up stack frame and save callee-save registers */
+        addi.d    $sp, $sp, -208
+        STORE   $ra, $sp, 192
+        STORE   $s0, $sp, 0
+        STORE   $s1, $sp, 8
+        STORE   $s2, $sp, 16
+        STORE   $s3, $sp, 24
+        STORE   $s4, $sp, 32
+        STORE   $s5, $sp, 40
+        STORE   $s6, $sp, 48
+        STORE   $s7, $sp, 56
+        STORE   $s8, $sp, 64
+        fst.d     $fs0, $sp, 96
+        fst.d     $fs1, $sp, 104
+        fst.d     $fs2, $sp, 112
+        fst.d     $fs3, $sp, 120
+        fst.d     $fs4, $sp, 128
+        fst.d     $fs5, $sp, 136
+        fst.d     $fs6, $sp, 144
+        fst.d     $fs7, $sp, 152
+    /* Shuffle arguments */
+        move      $t0, $a0
+        move      $a0, $a1
+        move      $a1, $a2
+        move      $a2, $a3
+        move      $a3, $a4
+    /* Call generated asm */
+        jirl    $ra, $t0, 0
+    /* Reload callee-save registers and return address */
+        LOAD    $ra, $sp, 192
+        LOAD    $s0, $sp, 0
+        LOAD    $s1, $sp, 8
+        LOAD    $s2, $sp ,16
+        LOAD    $s3, $sp ,24
+        LOAD    $s4, $sp ,32
+        LOAD    $s5, $sp ,40
+        LOAD    $s6, $sp ,48
+        LOAD    $s7, $sp ,56
+        LOAD    $s8, $sp ,64
+        fld.d     $fs0, $sp, 96
+        fld.d     $fs1, $sp, 104
+        fld.d     $fs2, $sp, 112
+        fld.d     $fs3, $sp, 120
+        fld.d     $fs4, $sp, 128
+        fld.d     $fs5, $sp, 136
+        fld.d     $fs6, $sp, 144
+        fld.d     $fs7, $sp, 152
+        addi.d    $sp, $sp, 208
+        jr      $ra
+
+        .globl  caml_c_call
+        .align  2
+caml_c_call:
+        jr      $t2
-- 
2.20.1

